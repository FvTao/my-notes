---
title: 编译技术笔记
mathjax: true
date: 2022-11-17 23:54:16
tags:
categories:
cover:
---

# 零、重要知识点索引

- [乔姆斯基文法体系](#乔姆斯基文法体系)
- [短语的查找](#短语的查找方案)
- [NFA的确定化](#NFA的确定化)
- [DFA的极小化](#DFA的极小化)
- [消除左递归的方法](#消除左递归的方法)
- [消除回溯的途径](#消除回溯的途径)
- [不带回溯的充分必要条件](#不带回溯的充分必要条件)
- [FIRST集的计算](#FIRST集的计算)
- [FOLLOW集的计算](#FOLLOW集的计算)
- [LL(1)分析表的构造](#分析表的构造)
- [算符优先文法：优先关系的定义](#优先关系的定义)
- [素短语](#素短语)
- [构造优先关系矩阵](#构造优先关系矩阵)
- [LR分析方法](#LR分析方法)
- [建造display区的规则](#建造display区的规则)
- [算法：划分基本块](#算法：划分基本块)
- [消除公共子表达式算法](#消除公共子表达式算法)
- [从DAG导出中间代码的启发式算法](#从DAG导出中间代码的启发式算法)
- [基本块的活跃变量数据流分析（基本思路：迭代）](#基本块的活跃变量数据流分析（基本思路：迭代）)
- [算法：基本块的到达定义数据流分析（迭代思想）](#算法：基本块的到达定义数据流分析（迭代思想）)
- [用数据流计算支配属性](#用数据流计算支配属性)
- [寄存器分配：图着色算法](#寄存器分配：图着色算法)
- [指令集架构](#指令集架构)

# 一、概论

## (一)基本概念

- 源程序：用**汇编语言**或**高级语言**编写的程序称为源程序

- 目标程序：用**目标语言**所表示的程序。
  - 目标语言：可以是介于源语言和机器语言之间的 “中间语言”，可以是某种机器的**机器语言**，也可以是某机器的**汇编语言**

- 翻译程序：将源程序转换为目标程序的程序称为翻译程序。 它是指各种语言的**翻译器**，包括**汇编程序**和**编译程序**，是汇编程序、编译程序以及各种变换程序的总称

- 汇编程序：若源程序用**汇编语言**书写，经过翻译程序得到用机器语言表示的程序，这时的翻译程序就称之为汇编程序，这种翻译过程称为“汇编”(Assemble）

- 编译程序：若源程序是用**高级语言**书写，经加工后得到目标程序， 这种翻译过程称“编译”（Compile)
- 解释程序：（Interpreter） 对源程序进行**解释执行**的程序

## (二)编译过程与编译器构造

### 1、编译过程

- 编译过程是指将**高级语言程序**翻译为等价的**目标程序**的过程

#### (1)词法分析

- 任务：分析和识别单词
  - 源程序是由字符序列构成的，词法分析扫描源程序(字符串)，根据语言的**词法规则**分析并识别单词，并以某种编码形式输出。

- 单词：是语言的基本语法单位，一般语言有四大类单词
  - 保留字或关键字：begin、end、if、for、while…
  - 标识符
  - 常量
  - 分界符和运算符：{、}、[、]、+、-、\*、/、…

#### (2)语法分析

- 任务：根据语法规则（即语言的文法），分析并识别出各种**语法成分**，如表达式、各种说明、各种语句、 过程、函数等，并进行语法**正确性检查**。

#### (3)语义分析、生成中间代码

- 任务：对识别出的各种语法成分进行语义分析， 并产生相应的中间代码
- 中间代码：一种介于**源语言**和**目标语言**之间的中间语言形式
  - 生成中间代码的目的： 
    - 1、便于做优化处理； 
    - 2、便于编译程序的移植
  - 中间代码的形式：编译程序设计者可以自己设计，常用的有**四元式、三元式、逆波兰表示**等

#### (4)代码优化

- 任务：目的是为了得到高质量的目标程序

#### (5)生成目标程序

- 任务：由中间代码很容易生成目标程序（地址指令序列）。这部分工作**与机器关系密切** ，所以要根据机器进行。在做这部分工作时（要注意充分利用累加器），也可以进行**优化处理**。

### 2、编译程序构造

#### (1)编译程序的逻辑结构

- 划分为5个基本阶段，7个逻辑部分

  ![](https://s3.uuu.ovh/imgs/2022/11/18/f801dd22b223801c.jpg)

#### (2)多层中间表示和遍

- 遍：对源程序（包括源程序中间形式）从头到尾扫描一次，并做有关的加工处理 ，生成新的源程序中间形式或目标程序，通常称之为一遍。

#### (3)前端和后端

- 前端：通常将与源程序有关的编译部分称为前端。 词法分析、语法分析、语义分析、中间代码生成、代码优化

  - 分析部分 
  - 特点：与源语言有关

- 后端：与目标机有关的部分称为后端。 目标程序生成（与目标机有关的优化）

  - 综合部分 
  - 特点：与目标机有关

  ![](https://s3.uuu.ovh/imgs/2022/11/18/c096e71f13db8fb9.jpg)



# 二、文法和语言

## (一)形式语言基础（只包含重要概念）

- 符号串集合的闭包运算：设A是符号串集合，定义$A^＋ ＝ A^1 ∪ A^2 ∪ A^3 ∪……∪ A^n ∪……$称为集合A的正闭包。 $A^* ＝ A^0 ∪ A^＋$称为集合A的闭包

- 语言的句子：B为单词集，句子是定义在B上的符号串。 若令C为句子集合，则$C \subset B^*$ 

## (二)文法（Grammer）

- 1、**文法**是对语言结构的定义与描述，即从形式上用于描述和规定语言结构的称为“文法”
  - 未涉及语义问题

- 2、语法规则：我们通过建立一组规则，来描述句子的语法结构。 规定用“::=”表示“由...组成”

- 3、由规则推导句子：有了一组规则之后，可以按照一定的方式用它们去推导或产生**句子**。
- 4、推导方法：从一个要识别的符号开始推导，即用相应规则的右部来替代规则的左部，每次仅用一条规则去进行推导。
  - 有若干语法成分同时存在时，我们总是从最左的语法成 分进行推导，这称之为**最左推导**，类似的有**最右推导**(还有**一般推导**）
  - 从一组语法规则可推出不同的句子
- 5、语法（推导）树：我们用语法（推导）树来描述一个句子的语法结构

## (三)文法和语言的形式定义

### 1、文法的定义

- 文法$G=(Vn, Vt, P, S)$
  - $Vn$：非终结符号集 
  - $Vt$：终结符号集 
  - $P$：产生式或规则的集合 
  - $S$：开始符号（识别符号）$S\in Vn$
- 规则的定义： 规则是一个有序对$(U, x)$，通常写为:  $U ::= x$ 或$U \rightarrow x,\quad|U| = 1,\quad |x| \geq 0$

### 2、推导的形式定义

- 1、定义单步推导

  文法$G:v＝xUy,\quad w＝xuy$,  

  其中$x,y \in V^*,\quad U \in V_n, \quad u \in V^* $,  

  若$U ::= u\in P$，则$v \overset{G}{\Longrightarrow} w$

  若$x＝y＝\varepsilon$, 有$U::=u$，则$U\overset{G}{\Longrightarrow}u$

- 2、定义多步推导（+）

  文法$G, \quad u^0 , u^1 , u^2 , ……,u^n \in V^+$

  $if\quad v= u0\overset{G}{\Longrightarrow}u^1\overset{G}{\Longrightarrow}u^2 ……\overset{G}{\Longrightarrow}u^n＝w$，则$v\underset{G}{\overset{+}{\Longrightarrow}}w$

- 3、定义多步推导（*）

  文法$G, \quad u^0 , u^1 , u^2 , ……,u^n \in V^+$

  $if\quad v\underset{G}{\overset{+}{\Longrightarrow}}w$，或$v = w$，则$v\underset{G}{\overset{*}{\Longrightarrow}}w$

- 4、规范推导：

  有$xUy \Rightarrow xuy$, 若$y\in V_t^*$,  则此推导为规范的，记为 $x U y \nRightarrow x u y$
  
  直观意义：规范推导＝最右推导
  
  最右推导：若规则右端符号串中有两个以上的非终结符时，先推右边的。 
  
  最左推导：若规则右端符号串中有两个以上的非终结符时，先推左边的。

### 3、语言的形式定义

- 句型：x是句型，则$Z\overset{*}{\Longrightarrow}x$且$x \in V^* $，即文法推出的符号串
- 句子：x是句子，则$Z\overset{*}{\Longrightarrow}x$且$x \in V^*_t $，即文法推出的终结符串

- 语言：$L(G[Z]) = \{x | x \in V_t^*,Z\overset{+}{\Longrightarrow}x\}$，即文法推出的句子的集合
- 形式语言理论可以证明以下两点
	- 已知文法，求语言，通过推导
	- 已知语言，构造文法，无形式化方法，更多是凭经验

### 4、递归文法

- 递归规则：规则右部有与左部相同的符号（非终结符）
	- 对于$U::= xUy$ 
	- 若$x=ε$, 即$U::= Uy$， 左递归 
	- 若$y=ε$, 即$U::= xU$， 右递归 
	- 若$x, y≠ε$，即$U::= xUy$，自嵌入递归
- 递归文法：文法$G$，存在$U∈V_n$
	- $if\quad U\overset{+}{\Longrightarrow}…U…$, 则G为递归文法
	- $if\quad U\overset{+}{\Longrightarrow}U…$, 则G为左递归文法
	- $if\quad U\Longrightarrow…U$, 则G为右递归文法
- 递归文法的优点：可用有穷条规则，定义无穷语言
- 左递归文法的缺点：不能用自顶向下的方法来进行语法分析

## (四)文法构造

- 略，玄学问题

## (五)短语、简单短语和句柄（重点）

- 给定文法$G[Z]$，$w = xuy∈V^+$，为该文法的句型
	- 若 $Z \overset{*}{\Longrightarrow} xUy$，且$U \overset{+}{\Longrightarrow} u$, 则u是句型w相对于U的**短语**
	- 若 $Z \overset{*}{\Longrightarrow} xUy$，且$U\Longrightarrow u$, 则u是句型w相对于U的**简单短语**
	- **直观理解**：短语u 是目标句型w的一部分或全部，是推导过程 的前面某个句型(xUy)中的某个非终结符(U)所能推出的符号串，简单短语是一步推导得出的短语
	- 任何句型本身一定是相对于识别符号Z的短语

- 任一句型的最左简单短语称为该句型的**句柄**
- **注意**：短语、简单短语是相对于句型而言的，一个句型 可能有多个短语、简单短语，而句柄只能有一个

## (六)语法树（推导树）

### 1、语法树与二义性文法

#### (1)语法树

- 1、语法（推导）树：句子( 句型）结构的图示表示法，它是有向图，由结点和有向边组成
	- 结点：符号 
		- 根结点： 识别符号（非终结符） 
		- 中间结点：非终结符 
		- 叶结点： 终结符或非终结符
	- 有向边：表示结点间的派生关系

- 2、句型的推导及语法树的生成（自顶向下）
	- 简单，有什么难的（doge）
	- **注意**：文法所能产生的句子，可以 用不同的推导序列（使用产生式顺序不同）将其推导出来。语法树的生长过程不同，但最终生成的**语法树形状完全相同**

- 3、子树与短语

	- 子树：语法树中的某个结点（子树的根）连同它向下 派生的部分所组成
	- <span id = "短语的查找方案">定理：某子树的末端结点按自左向右顺序为句型中的符号串，则该符号串为该句型的相对于该子树根的**短语**（用这个找短语比较快）</span>

- 4、树与推导
- 由推导构造语法树
   - 从识别符号开始，自左向右建立推导序列，由根结点开始，自上而下建立语法树
   - 由语法树构造推导
   	- 自下而上地修剪子树的某些末端结点（短语），直至 把整棵树剪掉（留根），每剪一次对应一次归约
   	- 从句型开始，自右向左地逐步进行归约，建立推导序列
   	- 通常我们每次都剪掉当前句型的句柄（最左简单短语） 即每次均进行规范归约
   - 定义：对句型中最左简单短语（句柄）进行的归约称为**规范归约**

- 定义：通过规范推导或规范归约所得到的句型称为**规范句型**

#### (2)二义性文法

- 文法的二义性
	- 若对于一个文法的某一句子（或句型） 存在两棵**不同的语法树**，则该文法是**二义性文法**， 否则是无二义性文法
	- 若一个文法的某句子存在两个**不同的规范推导**，则该文法是二义性的，否则是无二义性的
	- 若一个文法的某规范句型的**句柄不唯一**，则该文法 是二义性的，否则是无二义性的
	- 换而言之，无二义性文法的句子只有一棵语法树，尽管推导过程可以不同
- 文法的二义性是不可判定的

## (七)文法的其它表示法

- 1、扩充的BNF表示 

	- BNF的元符号： < , >, ::= , | 
	- 扩充的BNF的元符号： < , >, ::= , | , { , } , [ , ] , ( , )

- 2、语法图

	![](https://s3.uuu.ovh/imgs/2022/11/23/97a4206f099a90b8.jpg)

## (八)<span id = "乔姆斯基文法体系">乔姆斯基文法体系</span>

- 文法和语言分类：0型、1型、2型、3型 这几类文法的差别在于对产生式（语法规则）施加不同的限制

- 0型文法

	- $P: u ::= v$ 其中 $u∈V^＋,v∈V^*,V = V_n∪V_t$
	- 0型文法称为**短语结构文法**。规则的左部和右部都可以是符号串，一个短语可以产生另一个短语
	- 0型语言：L0这种语言可以用**图灵机**(Turing)接受。

- 1型文法

	- $P:xUy ::= xuy$其中$U∈V_n,\quad x,y,u∈V^*$
	- 称为上下文敏感或**上下文有关文法**。也即只有在x、y这样的 上下文中才能把U改写为u
	- 1型语言：L1 这种语言可以由一种**线性界限自动机**接受

- 2型文法

	- $P:U::=u$其中$U∈V_n,\quad u∈V^*$
	- 称为**上下文无关文法**。也即把U改写为u时，不必考虑上下文。 (1型文法的规则中x，y均为 $ε$ 时即为2型文法）
	- 注意：2型文法与BNF表示相等价
	- 2型语言：L2 这种语言可以由**下推自动机**接受

- 3型文法

	- 左线性：$P:U ::= t$ 或$U::= Wt$其中$U,W∈V_n,\quad t∈V_t$
	- 右线性：$P:U ::= t$ 或$U::= tW$其中$U,W∈V_n,\quad t∈V_t$
	- 3型文法称为**正则文法**。它是对2型文法进行进一步限制
	- 3型语言：L3 又称正则语言、正则集合这种语言可以由**有穷自动机**接受

- 语言间的关系

	![](https://s3.uuu.ovh/imgs/2022/11/23/5423ec818c8b1cab.jpg)

# 三、词法分析

## (一)词法分析的功能

- 词法分析：根据词法规则识别及组合单词，进行词法检查。 
- 删去空格字符和注释。 
- 对数字常数完成数字字符串到二进制数值的转换
- 词法分析程序的输出形式-----单词的内部形式
	- 几种常用的单词内部形式：
	- 1、按单词种类分类
	- 2、保留字和分界符采用一符一类
	- 3、标识符和常数的单词值又为指示字（指针值）

## (二)正则文法和状态图

- 状态图的画法（根据文法画出状态图）

	- 左线性文法的状态图的画法：

		```
		// 正则文法
		Z --> U0 | V1
		U --> Z1 | 1
		V --> Z0 | 0
		```

	- 1、令G的每个非终结符都是一个状态

	- 2、设一个开始状态S

	- 3、若$Q::=T, Q ∈V_n,T ∈V_t$则：

		```mermaid
		graph LR
		    S((S))-->|T|Q((Q))
		```

	- 4、若$Q::=RT,\quad Q,R∈V_n,T ∈V_t$则：

		```mermaid
		graph LR
		    R((R))-->|T|Q((Q))
		```

	- 5、按自动机方法，可加上开始状态和终止状态标志

- 识别算法

	利用状态图可按如下步骤分析和识别字符串x： 

	- 1、置初始状态为当前状态，从x的最左字符开始， 重复步骤2，直到x右端为止。 
	- 2、扫描x的下一个字符，在当前状态所射出的弧中 找出标记有该字符的弧，并沿此弧过渡到下一个状 态；如果找不到标有该字符的弧，那么x不是句子， 过程到此结束；如果扫描的是x的最右端字符，并 从当前状态出发沿着标有该字符的弧过渡到下一个 状态为终止状态Z，则x是句子。

## (三)从“状态图”到“有穷状态自动机”

### 1、确定的有穷自动机(DFA)

- 一个确定的有穷自动机(DFA)M是一个五元式：$M=(S, Σ，δ, s_0, Z)$

	- $S$ —有穷状态集
	- $Σ$ —输入字母表 
	- $δ$ —映射函数(也称状态转换函数) $S×Σ→S\quad δ(s,a)=s’\quad s, s’ ∈S, a∈Σ$ 
	- $s_0$ —初始状态 $s0 ∈S$ 
	- $Z$—终止状态集 $Z\subseteq S$

- DFA  M所接受的符号串：令$α= a_1a_2...a_n，α∈Σ$，若$δ(δ(...δ(s_0, a_1),a_2)...),a_{n-1}),a_n) = S_n$ ,且$S_n ∈Z$，则可以写成$δ(s_0, α)= S_n$，我们称$α$可为 M所接受

	换言之：若存在一条 初始状态到某一终止状态的路径，且这条 路径上能有弧的标记 符号连接成符号串α，则称α为DFA M（接受）识别。

	DFA M所接受的语言为：$L(M)=\{α|δ(s_0, α)= S_n, S_n∈Z\}$

### 2、不确定的有穷自动机(NFA)

- 若$δ$是一个多值函数，且输入可允许为$ε$，则有穷自动机是不确定的，即在某个状态下，对于某个输入字符存在多个后继状态

- 从同一状态出发，有以同一字符标记的多条边，或者有 以$ε$标记的特殊边的自动机

- NFA的形式定义为：

	一个非确定的有穷自动机NFA M’是一个五元式：$NFA\quad M’=(S, Σ∪\{ε\}, δ, s_0, Z)$ 

	- $S$—有穷状态集 
	- $Σ∪\{ε\}$—输入符号加上$ε$, 即自动机的每个结点所射出的弧可以是$Σ$中的一个字符或是$ε$ 
	- $s_0$—初态 $s0 ∈S$
	- $Z$—终态集 $Z\subseteq S$ 
	- $δ$—转换函数 $S×Σ∪\{ε\} →2^S$  ($2^S$ —S的幂集：S的子集构成的集合）

- NFA M’所接受的语言为：$L(M’)=\{α|δ(s_0,α)=S’,S’∩Z≠\emptyset\}$

### 3、正则表达式基础

- 正则表达式：另一种在$Σ^*$上识别语言的方法
- 有字母表$\Sigma$，定义在$\Sigma$上的正则表达式和正则集合递归定义如下
	- 1、$\varepsilon$和$\emptyset$都是$\Sigma$上的正则表达式，其正则集合分别为：$\{\varepsilon\}$和$\emptyset$;
	- 2、任何$a \in \Sigma$ ，a是$\Sigma$上的正则表达式，其正则集合为：$\{a\}$
	- 3、假定$U$和$V$是$\Sigma$上的正则表达式，其正则集合分别记为$L(U)$和$L(V)$，那么$U|V$，$U·V$和$U^*$也都是$\Sigma$上的正则表达式，其正则集合分别为$L(U) \cup L(V)$、 $L(U) · L(V)$和$L(U)^*$
	- 4、任何$\Sigma$上的正则表达式和正则集合均由1、2和3产生
- 正则表达式中的运算符： 
	- $|$——或（选择） 
	- $·$ ——连接 
	- $*$或 $\{\}$——重复 
	- $()$——括号
- 运算符的优先级： 
	- 先* 
	- 后 • 
	- 最后 | 
	- • 在正则表达式中可以省略
- 正则表达式的性质： 
	- 设e1, e2和e3均是某字母表上的正则表达式, 则有: 
		- 单位正则表达式: $\varepsilon e = e\varepsilon = e$ 
		- 交换律: $e1 | e2 = e2 | e1 $
		- 结合律: $e1|(e2|e3) = (e1|e2)|e3\quad e1|(e2|e3) = (e1|e2)|e3 $
		- 分配律:$$ e1(e2|e3) = e1e2|e1e3 \quad (e1|e2)e3 = e1e3|e2e3 $$
		- 此外:$ r^* = (r|\varepsilon)^*\quad r^{**}=r^* \quad (r|s)^* = (r^*s^*)^* $

- 正则表达式与3型文法等价

## (四)<span id = "NFA的确定化">NFA的确定化</span>

- 定义1：集合$I$的$ε-$闭包：

	令$I$是一个状态集的子集，定义$ε-closure(I)$为： 

	- 1、若$s∈I$，则$s∈ε-closure(I)$； 
	- 2、若$s∈I$，则从$s$出发经过任意条$ε$弧能够到达的任何状态都属于$ε-closure(I)$。 状态集$ε-closure(I)$称为$I$的$ε-$闭包。

- 定义 2：令I是NFA M'的状态集的一个子集, $a \in \Sigma$

	- 定义: $I_{\mathrm{a}}=\varepsilon$-closure $(J)$
	- 其中 $J=\bigcup_{\mathrm{s} \in \mathrm{I}} \delta(\mathrm{s}, \mathrm{a})$
	- $J$是从状态子集$I$中的每个状态出发，经过标记为$a$的弧而 达到的状态集合
	- $I_a$是状态子集，其元素为$J$中的状态,加上从$J$中每一个状态出发通过$ε$弧到达的状态

- 确定化方法

	- 先求出初始状态$s_0$的$\varepsilon-$闭包

		这个状态集是第一个新状态（也就是转化后DFA的状态）。从这个状态集开始进行识别符号、状态转移的工作，状态转移产生的新状态都是确定化的DFA的状态。

	- 对新产生的状态集进行状态转换的分析

		识别一个符号集中的符号，按照上述第2个定义，求出所达到的状态集（DFA的状态）。若该状态集没有出现过，则添加到待分析的列表中。

		可以先算出NFA每个状态的$\varepsilon-$闭包，所达到的状态集就是识别某个符号后到达的所有状态的$\varepsilon-$闭包的并集。

	- 若还有新产生的状态集没有分析，则重复上一步

- 形式化表述

	见[形式语言与自动机理论]()

## (五)<span id = "DFA的极小化">**DFA的极小化**</span>

- 对于任一个DFA，存在一个唯一的状态最少的等价的DFA
- 一个有穷自动机是化简的$\Longleftrightarrow$它没有多余状态并且它的状态中没有两个是互相等价的。

- 一个有穷自动机可以通过消除多余状态和合并等价状态 而转换成一个最小的与之等价的有穷自动机

- 定义：

	- 有穷自动机的多余状态：从该自动机的开始状态出发，任何输入串也不能到达那个状态
	- 等价状态：状态s和t的等价条件是
		- 一致性条件：状态s和t必须同时为可接受状态或不接受状态
		- 蔓延性条件：对于所有输入符号，状态s和t必须转换到等价的状态里
		- 对于所有输入符号$c$，$Ic(s)=Ic(t)$，即状态$s、t$对于$c$具有相同 的后继，则称$s，t$是等价的。（任何有后继的状态和任何无后继的状态一定不等价）
		- 有穷自动机的状态s和t不等价,称这两个状态是可区别的

- 极小化算法

	输入：给定的DFA
	输出：可区分状态表

	算法：

	![DFA极小化算法](https://s3.uuu.ovh/imgs/2022/12/01/72eac705deb2c875.jpg)

- 示意图

	![](https://s3.uuu.ovh/imgs/2022/12/01/1afbc32a15dbc23f.jpg)

## (六)词法分析的自动化

- 词法分析程序的自动生成器—LEX（LEXICAL）
- 原理：给定RE → NFA → DFA → 极小化，从而自动生成词法分析程序
- … …

## (七)词法分析程序 getSymbol()

```mermaid
graph LR
	A["词法规则"] --> B["状态图"] --> C["词法分析程序"]
```

- 不是理论的重点，不做详细介绍

# 四、语法分析

## (一)语法分析

- 根据语法规则（即语言的文法），分析并识别出 各种语法成分，如表达式、各种说明、各种语句、 过程、函数等，并进行语法正确性检查
- 自顶向下（Top-Down）分析：推导（Derivations）
- 自底向上（Bottom-Up）分析：规约（Reductions）

## (二)自顶向下分析

### 1、自顶向下分析的一般过程

- 给定符号串S，若预测是某一语法成分，则可根据该语法成分的文法，设法为S构造一棵语法树， 若成功,则S最终被识别为某一语法成分，即 $S∈L(G[Z])$，其中G[Z]为某语法成分的文法 若不成功, 则 $S∈L(G[Z]) $
- 自顶向下分析方法特点：
	- 分析过程是带预测的，对输入符号串要预测属于什么 语法成分，然后根据该语法成分的文法建立语法树
	- 分析过程是一种试探过程，是尽一切办法(选用不同 规则) 来建立语法树的过程, 由于是试探过程, 难免 有失败, 所以分析过程需进行回溯, 因此也称这种方法 是带回溯的自顶向下分析方法
	- 最左推导可以编写程序来实现, 但带溯的自顶向下分 析方法在实际上价值不大, 效率低

### 2、自顶向下分析存在的问题及解决方法

#### (1) 左递归文法

- 有如下文法： 令$U$是文法的任一非终结符，文法中有规则$ U∷=U...$或者$U^+ := U...$这个文法是**左递归**的
- 自顶向下分析的基本缺点是： 不能处理具有左递归性的文法
	- 如果在匹配输入串的过程中，假定正好轮到要用非终结 符U直接匹配输入串，即要用U的右部符号串U¨¨去匹配， 为了用U¨¨去匹配，又得用U去匹配，这样无限的循环下 去将无法终止。
- 要实行自顶向下分析，必须要消除文法的左递归

##### <span id = "消除左递归的方法">**消除左递归的方法**</span>

- 方法一，使用扩充的BNF表示来改写文法

	- 规则一（提因子）

		- 若: $U::=xy|x w|x z$
			则可改写为： $U::=x(y|w|...|z)$
			若： $y=y_1 y_2, w=y_1 w_2$
			则 $U::=x(y_1(y_2|w_2)|...|z)$

		------

		- 若有规则：$U∷=x|xy $

			则可以改写为：$U∷=x(y|ε)$ 

			注意：不应写成$U∷=x(ε|y)$

		- 使用提因子法，不仅有助于消除直接左递归，而且有 助于压缩文件的长度，使我们能更有效地分析句子

	- 规则二

		- 若有文法规则：$U∷=x|y|……|z|Uv$

			可以改写为$U∷=(x|y|……|z)\{v\}$

		- 其特点是：具有一个直接左递归的右部并位于最后， 这表明该语法类U是由x或y……或z其后随有零个或多个v组成

	- 通过以上两条规则，就能消除文法的直接左递归， 并保持文法的等价性

- 方法二，将左递归规则改为右递归规则

	- 规则三

		- 若$P∷=P\alpha|\beta$

			则可改写为

			$P ∷= \beta P’$

			$P’ ∷= \alpha P’| ε$

- 消除所有左递归的算法

	![](https://s3.uuu.ovh/imgs/2022/12/01/a07b61a93c2ed32c.jpg)

#### (2)回溯问题

- 造成回溯的条件：文法中，对于某个非终结符号的规则其右部 有多个选择，并根据所面临的输入符号不能准确 地确定所要的选择时，就可能出现回溯
- 定义$\operatorname{FIRST}\alpha_i=\{a \mid \alpha_i \stackrel{*}{\Rightarrow} a \ldots, a \in V_t\}$
- 为避免回溯, 对文法的要求是:
	$\operatorname{FIRST}\left(\alpha_i\right) \cap \operatorname{FIRST}\left(\alpha_j\right)=\varphi(i \neq j)$

------

##### <span id = "消除回溯的途径">**消除回溯的途径**</span>

- 1、改写文法：对具有多个右部的规则反复提取左因子

	- $U∷=xV|xW\quad U, V, W∈V_n, x∈V_t^+ $

		改写为$U∷=x(V|W)$

		$U∷=xZ\quad Z∷=V|W$

	**注意：**问题到此并没有结束，还需要 进一步检查V和W的首符号是否相交

- 2、超前扫描（偷看）
	
	- 当文法不满足避免回溯的条件时，即各选择的首符号相 交时，可以采用超前扫描的方法，即向前侦察各输入符 号串的第二个、第三个符号来确定要选择的目标

------

- 为了在不采取超前扫描的前提下实现不带回溯的自顶向下分析，文法需要满足两个条件：

	- 文法是非左递归的
	- 对文法的任一非终结符，若其规则右部有多个选择时， 各选择所推出的终结符号串的首符号集合要两两不相交

	- 定义

		$\operatorname{FOLLOW}(\mathbf{A})=\left\{\mathbf{a} \mid \mathbf{Z} \stackrel{*}{\Rightarrow} \ldots \ldots \mathbf{A a} \ldots, \quad \mathbf{a} \in \mathbf{V}_t\right\}\mathbf{A} \in \mathbf{V}_{\mathbf{n}}, \mathbf{Z}$ 识别符号，该集合称为 $\mathrm{A}$ 的后继符号集合。
		特殊地: 若 $Z \stackrel{*}{\Rightarrow} \ldots A$则#$\in FOLLOW(A)$
		
	- <span id = "不带回溯的充分必要条件">**不带回溯的充分必要条件**</span>是：对于G的 每一个非终结符A的任意两条规则$A::=α|β$,下列条件成立：

		- $FIRST(α) ∩ FIRST(β) = \empty$
		- 若$β\overset{*}{\Longrightarrow}ε, 则FIRST(α) ∩ FOLLOW(A) = \empty$

### 3、递归子程序法（递归下降分析法）

- 具体做法：对语法的每一个非终结符都编一个分析程序， 当根据文法和当时的输入符号预测到要用某个非终结符 去匹配输入串时，就调用该非终结符的分析程序
- 不是理论重点，不做详细介绍

### 4、LL(1)文法

- 含义：
	- L：从左向右分析 (Left to right) 
	- L：产生“最左推导”(Left-most derivation) 
	- k=1：向前查看“k=1”个符号

#### (1)<span id = "FIRST集的计算">FIRST集的计算</span>

设$\alpha =X_1X_2……X_n, X_i\in V,求FIRST(\alpha)$

1. $若X_i\in V_t,则FIRST(X_i)=\{X_i\}$

2. $若X_i\in V_n且X_i::=a……|\varepsilon,a\in V_t,则FIRST(X_i)=\{a, \varepsilon\}$

3. $若X_i\in V_n且X_i::=y_1y_2……y_k,则将FIRST(y_1)-\{\varepsilon\}加入FIRST(X_i)中$

	$并依次考虑\varepsilon\in FIRST(y_j)的情况\quad j=1,2,3...\\并将FIRST(y_{j+1})-\{\varepsilon\}加入FIRST(X_i)中$

	注意：要顺序往下做，一旦不满足条件，过程就要中断进行

5. 得到$FIRST(Xi)$，即可求出$FIRST(α)$。

#### (2)<span id = "FOLLOW集的计算">FOLLOW集的计算</span>

设$S,A,B\in V_n$，连续使用以下规则，直到$FOLLOW$集不再扩大

1. 若$S$为识别符号，则把**#**加入$FOLLOW(S)$中
2. 若$A::=\alpha B \beta(\beta \not= \varepsilon)$，则把$FIRST(\beta)-\{\varepsilon\}$加入$FOLLOW(B)$
3. 若$A::=\alpha B或A::=\alpha B\beta$，且$\beta\overset{*}{\Longrightarrow}\varepsilon$，则把$FOLLOW(A)$加入$FOLLOW(B)$中

注：$FOLLOW$集合中不能有 $ε$

### 5、LL(1)分析法

#### (1)LL分析程序构造及分析过程

- 由三部分组成:  

	- 分析表 

		二维矩阵$M,A∈V_n,a ∈ V_t \cup \{$#$\}$ 
		$$
		M[A,a]=
		\begin{cases}
		    A \rightarrow \alpha_i \\
		    error
		\end{cases}
		$$
	
- 执行程序 (总控程序） 
	
	- 执行程序主要实现如下操作：
			- 把#和文法识别符号E推进栈, 读入下一个符号， 重复下述过程直到正常结束或出错。
		- 测定栈顶符号X和当前输入符号a,执行如下操作:
		  - 1、若$X=a=$ #，分析成功，停止。E匹配输入串成功。 
		  - 2、若$X=a≠$ #，把X推出栈，再读入下一个符号。 
		  - 3、若$X∈V_n$，查分析表M。
		  	- a) $M[X,a] = X∷= UVW$ 则将X弹出栈，将$UVW$压入 注：$U$在栈顶 （最左推导） 
		  	- b) $M[X, a] = error $转出错处理 
		  	- c) $M[X, a] = X::=ε$，——$a$为$X$的后继符号则将$X$弹出栈 (不读下一符号) 继续分析。
	
- 符号栈 （分析栈）
	
	- 开始状态
	- 工作状态
	- 出错状态
	- 结束状态

#### (2)<span id = "分析表的构造">分析表的构造</span>

- 基本思想: 当文法中某一非终结符呈现在 栈顶时, 根据当前的输入符号, 分析表应指示要用该非终结符 的哪一条规则去匹配输入串 (即进行一步最左推导)

- 算法：

	- 设$A∷=α_i$为文法中的任意一条规则，$a$为任一终结符或#。 
	- 1、若$a ∈FIRST(α_i)$，则$A::= α_i \Rightarrow M[A,a]$ 
		- 表示：A在栈顶，输入符号是a，应选择$α_i$去匹配 
	- 2、若$α_i =ε$或$α_i\overset{+}{\Longrightarrow}ε$,而且$a ∈FOLLOW(A)$，则$A::= α_i\Rightarrow M[A,a]$，
		- 表示A已经匹配输入串成功，其后继符号终结符a由A后面的语法成分去匹配。 
	- 3、把所有无定义的$M[A,a]$都标上$error$

- 栗子

	```
	E ::= TE’
	E’::= +TE’|ε
	T ::= FT’
	T’::= *FT’|ε
	F ::= (E)|i
	```

	![](https://s3.uuu.ovh/imgs/2022/12/02/4d9ad3c67d899122.jpg)

	![](https://s3.uuu.ovh/imgs/2022/12/02/22c64b957d66707b.jpg)
	
	![](https://s3.uuu.ovh/imgs/2022/12/05/c8d3a0a6d989438c.jpg)

## (三)自底向上分析

- 移进—归约分析（Shift-Reduce Parsing) 
- 要点：建立符号栈，用来记录分析的历史和现状，并根据所面临的状态，确定下一步动作是移进还是归约
- 要解决的问题
	- 句柄识别问题
	- 何时归约句柄
	- 何时把终结符移进符号栈

### 1、算符优先分析(Operator-Precedence Parsing)

- 这是一种经典的自底向上分析法，简单直观，并被广泛使 用，开始主要是对表达式的分析，现在已不限于此。可以 用于一大类上下无关的文法

- 称为算符优先分析是因为这种方法是仿效算术式的四则运算 而建立起来的，作算术式的四则运算时，为了保证计算结果和过程的唯一性，规定了一个统一的四则运算法则，规定运 算符之间的优先关系

- 算符优先分析的特点：仿效四则运算过程，预先规定相邻终结符之间的优 先关系，然后利用这种优先关系来确定句型的“句柄” ， 并进行归约

- 分析器结构：

	![](https://s3.uuu.ovh/imgs/2022/12/04/35d3eea179b3095a.jpg)

- 终结符之间的优先关系

	设$a，b$为可能相邻的终结符

	- $a=b$，优先级相等，栈内$a$、栈外$b$抵消
	- $a<b$，$b$的优先级高，栈外$b$移进
	- $a>b$，$a$的优先级高，栈内$a$规约

### 2、算符优先文法

- 若文法中无形如$U::=VW,\quad V、W\in V_n$的规则，则称文法为OG文法，也就是算符文法。

- 设有一OG文法，如果在任意两个终结符之间，至多只有 上述关系中的一种，则称该文法为算符优先文法(OPG)

- <span id = "优先关系的定义">**优先关系的定义**</span>

	- $a=b$，文法中有形如$U:==…ab…或U::=aVb$的规则

	- $a<b$，文法中有形如$U::=…aW…$的规则，其中$W\overset{+}{\Longrightarrow}b…或W\overset{+}{\Longrightarrow}Vb…$

		$a$的后面有非终结符$W$，向后遇到$W$第一个终结符$b$时，应该先移进，以适用本条规则

	- $a>b$，文法中有形如$U::=…Wb…$的规则，其中$W\overset{+}{\Longrightarrow}…a或W\overset{+}{\Longrightarrow}…aV$

		$W$的后面有终结符$b$，$W$的最后一个终结符$a$向后遇到$b$时，应该先规约，以适用本条规则

- <span id = "构造优先关系矩阵">**构造优先关系矩阵**</span>

  - 求 “ $=$ ” 检查每一条规则，若有$U::=…ab…或 U::=…aVb…$, 则 $a=b$

  - 求“ $<$”、“$ > $” ，需定义两个集合
  	- $FIRSTVT(U)=\{b|U\overset{+}{\Longrightarrow}b…或U\overset{+}{\Longrightarrow}Vb…\}$
  		- 若有规则$U∷= b…$或$U∷= Vb…(存在U\overset{+}{\Longrightarrow}b…或U\overset{+}{\Longrightarrow}Vb…) $则$b∈FIRSTVT(U)$
  		- 若有规则$U∷= V…$且$b∈FIRSTVT(V)$，则$b∈FIRSTVT(U)$
  	- $LASTVT(U)=\{a|U\overset{+}{\Longrightarrow}…a或U\overset{+}{\Longrightarrow}…aV\}$
  		- 若有规则$U::=…a$或$U::=…aV$,则$a∈LASTVT(U)$
  		- 若有规则$U::=…V$,且$a∈LASTVT(V)$, 则$a∈LASTVT(U)$
  	- 若有文法规则$W::=…aU…$，则对任何$b\in FIRSTVT(U),a<b$
  	- 若有文法规则$W::=…Ub…$，则对任何$a\in LASTVT(U),a>b$
  	
  - 构造优先关系矩阵的算法

  	| 算法：                                                       |
  	| ------------------------------------------------------------ |
  	| $\mathrm{for\quad 每条规则U::=x_1x_2x_3...x_n}$<br />$\mathrm{\quad for\quad i \leftarrow 0\ \ to\ \ n-1\quad do}$<br />$\mathrm{\quad\quad if\quad x_i和x_{i+1}均为终结符\quad then\quad 置x_i=x_{i+1}}$<br />$\mathrm{\quad\quad if\quad i\leq n-2,且x_i和x_{i+2}都为终结符但x_{i+1}为非终结符\quad then\quad 置x_1=x_{i+2}}$<br />$\mathrm{\quad\quad if\quad x_i为终结符,x_{i+1}为非终结符\quad then}$<br />$\mathrm{\quad \quad \quad for\quad FIRSTVT(x_{i+1}中的每个b)\quad do\quad 置x_i<b}$<br />$\mathrm{\quad\quad if\quad x_i为非终结符,x_{i+1}为终结符\quad then}$<br />$\mathrm{\quad \quad \quad for\quad LASTVT(x_i中的每个a)\quad do\quad 置a<x_{i+1}}$<br />$\mathrm{\quad end}$ |

  	- $<$关系横向填表
  	- $>$关系纵向填表

  - eg:

  	```
  	E::= E + T | T
  	T::= T * F | F
  	F::= ( E ) | i
  	```

  	![](https://s3.uuu.ovh/imgs/2022/12/06/b89fe3f2f3b80bfc.jpg)

  	![](https://s3.uuu.ovh/imgs/2022/12/06/8fe1a395e3973878.jpg)

  	![](https://s3.uuu.ovh/imgs/2022/12/06/80e0f4e1b3d3e4b9.jpg)

- <span id = "素短语">**素短语**</span>

	文法G的句型的素短语是一个短语，它至少包含有一个终结符号，并且除它自身以外不再包含其他素短语

### 3、<span id = "LR分析方法">LR分析方法</span>

- 规范句型: 通过**规范归约**（Right-most）得到的句型

- 规范句型前缀: 将输入串的剩余部分与其连接起来就**构成了规范句型**

- 活前缀: 若分析过程能够保证栈中符号串均是规范句型的前缀，则表示输入串已分析过的部分没有语法错误，所以称为规范句型的活前缀

	- 对于句型$αβt$，$ β$表示句柄, 如果$αβ= u_1u_2…u_r $那么符号串$u_1u_2…u_i(1≤i≤r)$ 即是句型$αβt$的活前缀

	![](https://s3.uuu.ovh/imgs/2022/12/04/17c744c6291674ed.jpg)

#### (1)LR(0)分析法

- 分析表

	- 状态转移表 (GOTO表)
		- $GOTO[S_{i-1}, x_i]=S_i$
			- $S_{i-1}$---当前状态(栈顶状态) 
			- $x_i$--- 新的栈顶符号 
			- $S_i$----新的栈顶状态(状态转移)
		- $S_i$需要满足条件是: 每一步识别的都是“活前缀”

		![](https://s3.uuu.ovh/imgs/2022/12/04/9837e5c9624965e9.jpg)

	- 分析动作表(ACTION表) – 移进？规约？

		$ACTION[S_i,a] = $分析动作$ a∈V_t$

		![](https://s3.uuu.ovh/imgs/2022/12/04/7e1bbc20528d7004.jpg)

- 分析动作：

	- (1) 移进(shift) 

		$ACTION[S_i,a] = s$ （s表示 shift，移进） 

		动作: 将$a$推进栈，并设置新的栈顶状态$S_i,S_j= GOTO[S_i,a]$，将指针指向下一个输入符号

	- (2) 归约(reduce)

		$ACTION [S_i,a] = r_d $（r表示 reduce，按规则d规约） 

		d：文法规则编号 $(d) A→β $

		条件：某个项目集形如 $A→β. $

		动作: 将符号串$β$(假定长度为n)连同状态从栈内弹出, 把A推进栈, 并设置新的栈顶状态$S_i,S_j= GOTO[S_{i-n},A]$

	- (3) 接受(accept) 

		$ACTION[S_i,$#$]=accept$ （Si对应的是初始符号的产生式$S’→S$#对应的状态）

	- (4) 出错(error) 

		$ACTION[S_i,a]=error$

- **构造LR(0)分析表**

	- 1、 将文法拓广

		- 修改文法，使识别符号的规则只有一条

		![](https://s3.uuu.ovh/imgs/2022/12/04/d9a4e3ef55910197.jpg)

	- 2、根据文法列出所有的项目

		- 项目:文法G的每个产生式(规则)的右部添加一个圆点就构成一个项目
		- 项目的直观意义: 指明在分析过程中的某一时刻已经归约的部分和等待归约部分

		![](https://s3.uuu.ovh/imgs/2022/12/04/94941348e4e00f54.jpg)

	- 3、将有关项目组合成集合，即DFA中的状态； 所有状态再组合成一个集合，即LR（0）项目集规范族

		- 为实现这一步，先定义：

			- 项目集闭包closure

				![](https://s3.uuu.ovh/imgs/2022/12/04/4ed056212302c5db.jpg)

			- 状态转移函数GOTO

				![](https://s3.uuu.ovh/imgs/2022/12/04/54a957ab577cf0bf.jpg)

				- 所以,$GOTO(I,X) = closure(J)$ 的直观意义是: 识别文法规范句型活前缀的DFA, 从状态$ I$(项目集)出发,经过$X$弧所应该到达的状态(项目集合) 

	- LR(0)和GOTO的构造算法

		![](https://s3.uuu.ovh/imgs/2022/12/04/17c851dcb1a83065.jpg)

- 有效项目定义

	若项目$A→β_1 .β_2$ 对活前缀$αβ_1$ 有效，其条件是存在规范推导$E’\overset{*}{\Rightarrow}αAw\Rightarrow αβ_1β_2 w$，其中$α,β_1,β_2 ∈ V^*, w ∈ V_t^*$

	```
	E::= E + T | T
	T::= T * F | F
	F::= ( E ) | i
	```
	
	![](https://s3.uuu.ovh/imgs/2022/12/04/904936e9e948c785.jpg)

#### (2)LR(0)的局限性

- LR(0)在分析时会产生如下冲突：

	- Shift-Reduce冲突：应该移进还是规约？

		```
		E --> T·
		E --> T·+E
		```

	- Reduce-Reduce冲突：应该按照那个规则规约？

		```
		A --> abC·
		B --> abC·
		```

- LR(0)能够处理的情况有限：句柄必须在左侧栈顶，没有使用右侧上下文（right context）

	- 有些冲突不是真冲突，可以通过向后预读解决

#### (3)LR(1)分析法

- LR(1)的基本思想
	- 通过“偷看”一个右侧符号，在遇到冲突时辅助决定
	- 思路：将状态区分的更加细致，构造LR(1)的状态机
- 优势：**功能强大**！任何LR(0)、LL(1)、确定型CFL、 LL(k)、LR(k)都有LR(1)的等价文法
- 主要问题：**状态爆炸！实用性差！**

#### (4)SLR(1)：简单LR分析法

##### ①SLR的基本思想

- 兼有LR(0)和LR(1)的优点，放弃一些精度
- 在LR(0)的基础上，只针对冲突进行处理
- 当发生S-R冲突（Shift-Reduce冲突）时，根据 FOLLOW集合确定S还是R

##### ②构造SLR分析表

- 1、先构造LR(0)的自动机，GOTO表

- 2、SLR求ACTION表
	- 1、求出文法每个非终结符的FOLLOW集合
	- 2、若项目$A→α.aβ ∈k$，且$a ∈Vt$，则置$ACTION[k,a] = s$(移进）
	- 3、若项目$A→ α.∈k$, 那么对输入符号$a$，若$a∈FOLLOW(A)$，则置$ACTION[k,a]=r_j$其中$A→ α$为文法$$G’$$的第$j$个产生式。
	- 4、若项目$E’→E.∈k$, 则置$ACTION[ k , <end> ] = accept$
	- 5、空白格，均置$error$
	- 总结：在状态中可有三种类型的项目，其中只有两种有移进或归约动作: 
		- $A→ α.aβ\quad a∈Vt$移进项目——分析动作：移进 
		- $A→ α.$归约项目——分析动作：归约 
		- $A→ α.Bβ \quad B∈Vn$——待约项目：无动作
	- 根据上述算法,可以构造出文法$G’[E’]$的ACTION

- 3、合并ACTION和GOTO表形成分析表


# 五、符号表管理技术

## (一)概述

- 在编译过程中,编译程序用来记录源程序中各种 名字的特性信息, 所以也称为名字特性表

	- 名字：程序名、过程名、函数名、用户定义类型名、 变量名、常量名、枚举值名、标号名等。
	- 特性信息: 上述名字的种类、类型、维数、参数个数、 数值及目标地址（存储单元地址）等。

- 建表和查表的必要性

	当编译程序编译到引用所声明的变量时(赋值或引用其 值)，要进行语法语义正确性检查(类型是否符合要求)和生成相应的目标程序，这就需要查符号表以取得相关信息

- 有关符号表的操作：填表和查表

	填表：当分析到程序中的说明或定义语句时，将说明或 定义的名字，以及与之有关的信息填入符号表中。

	查表：(1) 填表前查表，检查在程序的同一作用域内名字 是否重复定义； (2) 检查名字的种类是否与说明一致； (3) 对于强类型语言，要检查表达式中各变量的类型 是否一致； (4) 生成目标指令时，要取得所需要的地址。

## (二)符号表的组织与内容

### 1、符号表的结构与内容

- 符号表的基本结构

	名字：存放名字，一般为标识符的符号串,也可 为指向标识符字符串的指针

	特性(信息)：可包括多个子域 , 分别表示标识符的有 关信息，如:

	- 名字(标识符)的种类:简单变量、函数、过程、 数组、标号、参数等 
	- 类型：如整型、浮点型、字符型、指针等 
	- 性质：变量形参、值形参等 
	- 值： 常量名所代表的数值 
	- 地址：变量所分配单元的首址或地址位移 
	- 大小：所占的字节数 
	- 作用域的嵌套层次:
		- 对于数组: 维数、上下界值、计算下标变量地址所用的 信息（数组信息向量）以及数组元素类型等。
		- 对于记录（结构、联合）：域的个数，每个域的域名、 地址位移、类型等。 
		- 对于过程或函数：形参个数、所在层次、函数返回值类型、 局部变量所占空间大小等。 
		- 对于指针：所指对象类型等。

### 2、符号表的组织方式

- 1、统一符号表:不论什么名字都填入统一格式的符号表中
	- 符号表表项应按信息量最大的名字设计,填表、 查表比较方便, 结构简单, 但是浪费大量空间。
- 2、对于不同种类的名字分别建立各种符号表
	- 节省空间, 但是填表和查表不方便。
- 3、折中办法:大部分共同信息组成统一格式的符号表， 特殊信息另设附表,两者用指针连接

### 3、非分程序结构语言的符号表组织

#### (1)非分程序结构语言

- 每个可独立进行编译的程序单元是一个不包含有子模块的单一模块，如FORTRAN语言、C语言

- 可以简单理解为函数内部不允许再定义函数

#### (2)标识符的作用域及基本处理办法

- 作用域: 
	- 全局:子程序名,函数名和公共区名
	- 局部: 程序单元中定义的变量
- 符号表的组织
	- 全局符号表
	- 局部符号表
- 基本处理办法
	1. 子程序、函数名和公共区名填入全局符号表
	2. 在子程序（函数）声明部分读到标识符，造局部符号表
		- 查本程序单元局部符 号表，有无同名？
			- 有,重复声明,报错
			- 无,造表
	3. 在语句部分读到标识符，查表
		- 查本程序单元局部符 号表，有无同名？
			- 有,即已声明
			- 无,查全局变量表
				- 有,全局量
				- 无, 无定义标识符
	4. 程序单元结束：释放该程序单元的局部符号表
	5. 程序编译完成：释放全部符号表

#### (3)符号表的组织方式

1. 无序符号表: 按扫描顺序建表,查表要逐项查找
	- 查表操作的平均长度为$n+1/2$
2. 有序符号表：符号表按变量名进行字典式排序
	- 线性查表: $n+1 / 2$ 
	- 折半查表: $\log_2n -1$
3. 散列符号表(Hash表)：符号表地址 = Hash(标识符)

### 4、分程序结构语言的符号表组织

#### (1)分程序结构语言

- 模块内可嵌入子模块

#### (2)标识符的作用域和基本处理方法

- 作用域：标识符局部于所定义的模块(最小模块)

	- 模块中所定义的标识符作用域是定义该标识符的子程序
	- 过程或函数说明中定义的标识符(包括形参)其作用域为本过程体
	- 循环语句中定义的标识符,其作用域为该循环语句

- 基本处理办法：

	建查符号表均要遵循标识符的作用域规定进行。 

	建表：不能重复,不能遗漏 

	查表：按标识符作用域

	处理方法:

	- 在程序声明部分读到标识符时(声明性出现),建表：

		- 查本层符号表,有无同名
			- 有,重复声明,报错
			- 无,填入符号表

	- 在语句中读到标识符(引用性出现),查表:

		- 查本层符号表,有无同名？
			- 有,即已声明, 取该名字信息(局部量)
			- 无,是否是最外层?
				- 是,未声明标识符,报错
				- 否,转到直接外层,重复上述**查表**过程

	- 标准标识符的处理（主要是语言定义的一些标准过程和函数的名字, 它们是标识符的子集）

		- 特点：1) 用户不必声明,就可全程使用 2) 设计编译程序时，标准名字及其数目已知

		- 处理方法：1) 单独建表：使用不便，费时。 2) 预先将标准名填入名字表中 （最外层）

# 六、运行时的存储组织及管理

## (一)概述

- **运行时的存储组织及管理**：目标程序运行时所需存储空间的组织与管理以及源程序中变量存储空间的分配

## (二)静态存储分配

- 在编译阶段由编译程序实现对存储空间的 管理和为源程序中的变量分配存储的方法
- 条件：如果在编译时能够确定源程序中变量在运行时的数据空间大小，且运行时不改变，那么就可以采用静态存储分配方法

### 1、分配策略

- 由于每个变量所需空间的大小在编译时已知，因 此可以用简单的方法给变量分配目标地址
	- 开辟一数据区。（首地址在加载时定）
	- 按编译顺序给每个模块分配存储空间。
	- 在模块内部按顺序给模块的变量分配存储，一 般用相对地址，所占数据区的大小由变量类型决定
	- 目标地址填入变量的符号表中

### 2、模块(FORTRAN子程序)的完整数据区

- 变量 

- 返回地址

- 形式参数

- 临时变量

	![](https://s3.uuu.ovh/imgs/2022/12/02/28e3d9de51736cf9.jpg)

## (三)动态存储分配

- 在目标程序运行阶段由目标程序实现对存 储空间的组织与管理，和为源程序中的变量分配存储的方法
- 特点：
	- 在目标程序运行时进行变量的存储分配
	- 编译时要生成进行动态分配的目标指令
- 分程序结构，且允许递归调用的语言： 栈式动态存储分配
- 分配策略: 整个数据区为一个堆栈
	- (1) 当进入一个过程时，在栈顶为其分配一个数据区。 
	- (2) 退出时，撤消过程数据区

### 1、活动记录

- 一个典型的活动记录可以分为三部分：

	- 1、存放模块中定义的各个局部变量。

	- 2、参数区： 存放隐式参数和显式参数。

		- 显式参数区(出现在用户源程序中)

		- 隐式参数区(不出现在用户源程序中)

			

		| 参数       | 解释                                                         | other      |
		| ---------- | ------------------------------------------------------------ | ---------- |
		| 形参数据区 | 每一形参都要分配数据空间,形参单元中存 放实参值或者实参地址   | 显式参数区 |
		| prev abp   | 存放调用模块记录基地址,函数执行完时,释放 其数据区，数据区指针指向调用前的位置 | 隐式参数区 |
		| ret addr   | 返回地址，即调用语句的下一条执行指令地址                     | 隐式参数区 |
		| ret value  | 函数返回值(无值则空)                                         | 隐式参数区 |

		

	- 3、display区：存放各外层模块活动记录的基地址

		- 变量二元地址(BL、ON)
			- BL：变量声明所在的层次
			- ON：相对于显式参数区的开始位置的位移

- 举个例子

	```fortran
	BLOCK; ! 1
	
		REAL X,Y; STRING NAME; 
		
		M1: PBLOCK(INTEGER IND); ! 2
			INTEGER X;
			CALL M2(IND+1); 
		END M1; 
		
		M2: PBLOCK(INTEGER J); ! 3
			BBLOCK; ! 4
				ARRAY INTEGER F(J);
				LOGICAL TEST1; 
			END ; 
		END M2;
		
		CALL M1(X/Y);
	END
	```

	$$
	1
	\begin{cases}
	    X,Y,NAME; \\
	    2
	    \begin{cases}
	   		M1:(IND); \\
	    	X; \\
	    	CALL M2
		\end{cases} \\
		3
	    \begin{cases}
	   		M2:(J); \\
	    	4
	        \begin{cases}
	            ARRAY\ \ F(J); \\
	            TEST1;
	        \end{cases}
		\end{cases}\\
		CALL\ \ M1
	\end{cases}
	$$

	- （a）（b）![](https://s3.uuu.ovh/imgs/2022/12/02/b8e9e345c66aaa92.jpg)

	- （c）（d）![](https://s3.uuu.ovh/imgs/2022/12/02/7ff31ee7ac727b9c.jpg)

	- （e）当模块4执行完，则abp:=prev abp，这样abp恢复 到进入模块4时的情况，运行栈情况如（c） 
	- （f）当M2执行完，则abp:=prev abp，这样abp恢复 到进入M2时的情况，运行栈情况如（b） 
	- （g）当M1执行完，则abp:=prev abp，这样abp恢复 到进入M1时的情况，运行栈情况如（a） 
	- （h）当最外层模块执行完，运行栈恢复到进入模块时的 情况，运行栈空

### 2、<span id = "建造display区的规则">建造display区的规则</span>

- 从i层模块进入(调用)j层模块，则：

	- 1、若j＝i＋1

		复制i层的display，然后增加一个指向i层模块记录基地址的指针

		![](https://s3.uuu.ovh/imgs/2022/12/02/4d2f4722659e97c3.jpg)

		![](https://s3.uuu.ovh/imgs/2022/12/02/a9ec054eccd48725.jpg)

	- 2、若j≤i 即调用外层模块或同层模块

		将i层模块的display区中的前面j－1个入口复制到第j层 模块的display区

		![](https://s3.uuu.ovh/imgs/2022/12/02/cfbd437ad42b69dc.jpg)

		![](https://s3.uuu.ovh/imgs/2022/12/02/260372145a919349.jpg)

### 3、运行时的地址计算

- | 地址计算公式：                                               |
	| ------------------------------------------------------------ |
	| $\mathrm{if\quad BL = LEV\quad then}$<br />$\quad \mathrm{addr \leftarrow adp+(BL-1)+nip+ON}$<br />$\mathrm{elif\quad BL < LEV\quad then}$<br />$\quad \mathrm{addr\leftarrow display[BL]+(BL-1)+nip+ON}$<br />$\mathrm{else}$<br />$\mathrm{\quad write(“地址错误”)}$ |

	$nip$：隐式参数区大小

	$(BL-1)$：Display区大小

# 七、源程序的中间形式

## (一)波兰表示

- 构造一个算法，生成“波兰表示”

	算法： 设一个操作符栈；当读到操作数时，立即输出该操作数， 当扫描到操作符时，与栈顶操作符比较优先级，若栈顶操作符优先级高于栈外，则输出该栈顶操作符，反之，则栈外操作符入栈

- if 语句的波兰表示

	- if 语句 ：`if <expr> then <stmt1> else <stmt2>`
	- 波兰表示为：`<expr> <label1>BZ <stmt1> <label2>BR <stmt2>`

## (二)N元表示

- 三元表达式：`|操作符|左操作数|右操作数|`

- 间接三元式：三元式的执行次序用另一张表表示,这样在优化时，三元式可以不变，而仅仅改变其执行顺序表

- 四元表达式：`|操作符|操作数1|操作数2|结果|`

- 一种特殊的四元式表达方式：SSA

	- Single Static Assignment form(SSA form)静态单一赋值 形式的 IR 主要特征是每个变量只赋值一次

	- SSA的优点： 1）可以简化很多优化的过程； 2）可以获得更好的优化结果

## (三)抽象语法树

- 抽象语法树： 用树型图的方式表示中间代码 操作数出现在叶节点上，操作符出现在中间结点
- DAG图： Directed Acyclic Graphs 有向无环图 语法树的一种归约表达方式

# 八、错误处理

- 略

# 九、语法制导翻译技术

## (一)翻译文法和语法制导翻译

### 1、翻译文法

- 输入文法：未插入动作符号时的文法。 由输入文法可以通过推导产生输入序列
- 翻译文法：插入动作符号的文法。 由翻译文法可以通过推导产生活动序列
- 活动序列：由翻译文法推导出的符号串，由终结符和动作 符号组成。 
	- 从活动序列中，抽去动作符号，则得输入序列
	- 从活动序列中，抽去输入序列，则得动作序列，执行动作序列，则完成翻译任务
- 定义：翻译文法是上下文无关文法，其终结符号集由输入符 号和动作符号组成。由翻译文法所产生的终结符号串称为活动序列

### 2、语法制导翻译

- 符号串翻译文法：若插入文法中的动作符号对应的语义子 程序是输出动作符号标记@后的字符串的文法
- 语法制导翻译(Syntax Directed Translation)：按翻译文法进行的翻译。 给定一输入符号串，根据翻译文法获得翻译该符号串的动作 序列，并执行该序列所规定的动作的过程
- 语法制导翻译的实现方法：
	- 在文法的适当位置插入语义动作符号，当按文法分析到动作 符号@时就调用相应的语义子程序，完成翻译任务
	- 翻译文法所定义的翻译是由输入序列和动作序列组成的对偶集

## (二)属性翻译文法

- 在翻译文法的基础上，可以进一步定义属性文法， 翻译文法中的符号，包括终结符、非终结符和动作符号 均可带有属性，这样能更好的描述和实现编译过程
- 综合属性：在语法树中，每个非终结符的属性值都是由其下面的符号来确定。这种可通过自底向上进行求值的属性，称为综合属性
- 继承属性：在产生式右部的符号的属性值，则是由其左部符号或同一右部但在其左边的符号的属性值求得。 由这种自顶向下、自左向右的求值规则求得的属性，称为继承属性

### 1、L-属性翻译文法（L-TAG）

- 这是属性翻译文法中较简单的一种。其输入文法要求是**LL(1)** 文法，可用自顶向下分析构造分析器。在分析过程中可进行属性求 值。

- 定义：L-属性翻译文法是带有下列说明的翻译文法：

	- 1、文法中的终结符，非终结符及动作符号都带有属性，且每个属性都有一个值域

	- 2、非终结符及动作符号的属性可分为继承属性和综合属性

	- 3、开始符号的继承属性具有指定的初始值

	- 4、输入符号（终结符号）的每个综合属性具有指定的初始值

	- 5、属性的求值规则：

		综合属性：

		- 1、产生式右部非终结符号的综合属性值，取其下部产生式左部同名非终结符号的综合属性值
		- 2、产生式左部非终结符号的综合属性值，用该产生式左部符号的继承属性或某个右部符号的属性进行计算
		- 3、动作符号的综合属性用该符号的继承属性或某个右部符号的属性进行计算

		继承属性：

		- 1、产生式左部非终结符号的继承属性值，取前面产生式右部该符号已有的继承属性值
		- 2、产生式右部符号的继承属性值，用该产生式左部符号的继承属性或出现在该符号左部的符号的属性值进行计算

### 2、简单赋值形式的L-TAG（SL-TAG）

- 定义：一个L-ATG被定义为简单赋值形式的(SL-ATG)，当且 仅当满足如下条件:

	- 产生式右部符号的继承属性↓是一个常量，它等于左部符号的继承属性值或等于出现在所给符号左边符号的一个综合属性值。
	- 产生式左部非终结符号的综合属性↑是一个常量，它等于左 部符号的继承属性值或等于右部符号的综合属性值

	因此，一个简单赋值形式的L-ATG除动作符号外，其余符号的 属性求值规则其右部是属性或是常量

- L-ATG $\Rightarrow$SL-ATG

	考虑产生式$<A>\rightarrow a_{\uparrow R}<B>_{\uparrow S}<C>_{\downarrow I}\quad I = f(r,s)$

	第一步：设动作符号“$@ f $” 表示函数$f$求值，该动作符 号有两个继承属性和一个综合属性。 $@f_{\downarrow I_1,I_2\uparrow S_1} 且 S1 := f (I_1 , I_2 )$

	第二步：修改产生式

	- 1、插入“$@ f$ ” （在适当位置）
	- 2、引进新的复写规则（将$R , S$ 赋给$I_1$和$I_2$ , $f$值赋给$S_1$ ）
	- 3、删去原有包含$f$的规则

	$<A>\rightarrow a_{\uparrow R}<B>_{\uparrow S}@f_{\downarrow I_1,I_2\uparrow S_1}<C>_{\downarrow I}\quad I = f(r,s)$

	$I_1 = R,\quad I_2=S,\quad S_1=f(I_1,I_2),\quad I=S_1$

# 十、语义分析和代码生成

- 略

# 十一、代码优化

- 代码优化：指编译程序为了生成高质量的目标程序而做的各种加工和处理
- 优化方法的分类1：
	- 与机器无关的优化技术：即与目标机无关的优化， 通常是在中间代码上进行的优化
	- 与机器相关的优化技术：充分利用系统资源，（指令系统，寄存器资源）
		- 特点：仅在特定体系结构下有效
- 优化方法的分类2：
	- 局部优化技术：指在基本块内进行的优化
	- 全局优化技术：函数/过程内进行的优化；跨越基本块
	- 跨函数（过程间）优化技术：整个程序范围内的优化

## (一)基本块、流图

### 1、基本块

- 基本块定义：

	- 基本块中的代码是连续的语句序列

	- 程序的执行（控制流）只能从基本块的第一条语句进入

	- 程序的执行只能从基本块的最后一条语句离开

	- 符合上述条件的最大块

- | <span id = "算法：划分基本块">算法：划分基本块</span>        |
	| ------------------------------------------------------------ |
	| 输入：四元式序列<br />输出：基本块列表，每个四元式仅出现在一个基本块中<br />方法：<br />    1、首先确定入口语句（每个基本块的第一条语句）的集合<br />        规则1：整个语句序列的第一条语句属于入口语句<br />        规则2：任何能由条件/无条件跳转语句转移到的第一条 语句属于入口语句<br />        规则3：紧跟在跳转语句之后的第一条语句属于入口语句 <br />    2、每个入口语句直到下一个入口语句，或者程序结束，它 们之间的所有语句都属于同一个基本块 |

### 2、流图

- 流图是一种有向图
- 流图的节点是基本块
- 如果在某个执行序列中，B2的执行紧跟在B1之后， 则从B1到B2有一条有向边
- 我们称B1为B2的前驱，B2为B1的后继
	- 从B1的最后一条语句有条件或者无条件转移到B2的第一条语句
	- 按照程序的执行次序，B2紧跟在B1之后，并且B1没有无条件转移到其他基本块

## (二)数据流分析

- 用于获取数据在程序执行路径中如何流动的有关信息，例如： 
	- 某个变量在某个特定的执行点（语句前后）是否还“存活” 
	- 某个变量的值，是在什么地方定义的
	- 某个变量在某一执行点上被定义的值，可能在哪些其他执 行点被使用
- 是局部优化、全局优化的基础

### 1、数据流分析方程

- 考察在程序的某个执行点的数据流信息
- $out[S] = gen[S]\cup(in[S]-kill[S])$
	- $S$：代表某条语句（基本块，基本块集合，或语句集合）
	- $out[S]$：代表在该语句**末尾得到**的数据流信息
	- $gen[s]$：代表该语句**本身产生**的数据流信息
	- $in[s]$：代表**进入**该语句时的数据流信息
	- $kill[S]$：代表该语句**注销**的数据流信息

- 数据流方程求解：3个关键因素
	- 当前语句产生和注销的信息取决于需要解决的具体 问题 ：可以由$in[S]$定义$out[S]$，也可以反向定义，由$out[S]$定义$in[S]$
	- 由于数据是沿着程序的执行路径，因此数据流分析的结果受到程序控制结构的影响
	- 代码中出现的诸如过程调用、指针访问以及数组成 员访问等操作，对定义和求解一个数据流方程都会 带来不同程度的困难

### 2、程序的状态

- 程序的执行过程：程序状态的变换过程
	- 程序状态由程序中的变量和其它数据结构组成
	- 每一条执行指令都可能改变程序的状态
- 通过数据流分析，可以了解程序的状态

## (三)局部优化（基本块内的优化）

### 1、利用代数性质（代数变换）

- 编译时完成常量表达式的计算，整数类型与实型的转换
- 下标变量引用时，其地址计算的一部分工作可在编译时 预先做好（运行时只需计算“可变部分”即可）
- 运算强度削弱：用一种需要较少执行时间的运算代替另一 种运算，以减少运行时的运算强度时、空开销）

### 2、常数合并和传播

- 如 x:=y 这样的赋值语句称为复写语句。由于 x 和 y 值相同，所 以当满足一定条件时，在该赋值语句下面出现的 x 可用 y 来代替

### 3、删除冗余代码（DCE: Dead Code Elimination）

- 冗余代码就是毫无实际意义的代码，又称死代码(dead code)或无用代码(useless code)。

### 4、窥孔优化（peep-hole）

- 窥孔优化关注在目标指令的一个较短的序列上， 通常称其为“窥孔” 
- 通过删除其中的冗余代码，或者用更高效简洁的 新代码来替代其中的部分代码，达到提升目标代码质量的目的

### 5、消除公共子表达式

- 可通过DAG图消除公共子表达式

- 图的叶节点由变量名或常量所标记。 对于那些在基本块内先引用再赋值的 变量，可以采用变量名加下标0的方式 命名其初值。

- 图的中间节点由中间代码的操作符所 标记，代表着基本块中一条或多条中间代码。 

- 基本块中变量的最终计算结果，都对 应着图中的一个节点；具有初值的变量，其初值和最终值可以分别对应不同的节点

- <span id = "消除公共子表达式算法">**消除公共子表达式算法**</span>

  - 输入：基本块内的中间代码序列

  - 输出：完成局部公共子表达式删除后的DAG图

  - 方法：

  	- 1、首先建立节点表，该表记录了变量名和常量值，以及它们当前所对应的DAG图中节点的序号。该表初始状态为空
  	- 2、从第一条中间代码开始，按照以下规则建立DAG图
  	- 3、对于形如`z = x op y`的中间代码，其中z为记录计算结果的变量名 ，x为左操作数，y为右操作数，op为操作符；首先在节点表中寻找x，如果找到，记录下x当前所对应的节点号i；如果未找到，在 DAG图中新建一个叶节点，假设其节点号仍为i，标记为x（如x为变量名，该标记更改为x~0~）；在节点表中增加新的一项`(x, i)`，表 明二者之间的对应关系。右操作数y与x同理，假设其对应节点号为j
  	- 4、在DAG图中寻找中间节点，其标记为op，且其左操作数节点号为i，右操作数节点号为j。如果找到，记录下其节点号k；如果未找到，在DAG图中新建一个中间节点，假设其节点号仍为k，并将节点i和j分别与k相连，作为其左子节点和右子节点
  	- 5、在节点表中寻找z，如果找到，将z所对应的节点号更改为 k；如果未找到，在节点表中新建一项(z, k)，表明二者之间的对应关系
  	- 6、对输入的中间代码序列依次重复上述步骤3～5

  	**或者**

  	- 首先建立**节点表**，该表初始状态为空。用来记录变量名和常量值，以及它们所对应的DAG图中节点的序号。	

  		随着算法执行，该表不断更新。

  	- 从第一条中间代码开始，执行下面的规则以建立DAG图

  		对于形如$z\,=\,x\,op\,y$的中间代码

  		- 第一步

  			先观察$=$右部，再观察$=$左部，也即按照执行顺序考虑

  			在节点表中找$x$，若有（假设节点号为$i$），则不必操作，只需记下节点号为$i$即可

  			若无，则在节点表中新建一个节点（假设编号为$i$），若$x$为常数，直接记录常数对应节点$i$即可，若$x$为变量，则记录$x_0$对应节点$i$。因为此时未在节点表中找到$x$，$x$的第一次出现就在右部（被使用），因此$x$的初值来自外部，标记为$x_0$，若$x$的值被更改，对应节点标记为$x$，从而将其区分为两个不同的节点。在$x$的值更改之前的引用为$x_0$，在$x$的值更改之后的引用为$x$

  			$y$同理，假设其节点编号为$j$

  		- 第二步

  			在节点表中找中间节点：其标记为$op$，左操作数节点为$i$，右操作数节点为$j$，也即与上述右部相同

  			若找到（假设节点编号为$k$），则不必操作，只需记下节点号$k$即可

  			若无，则在节点表中新建一个节点（假设编号为$k$），标记为$op$，左子节点为$i$，右子节点为$j$

  		- 第三步

  			在节点表中找$z$

  			若找到，则将对应节点编号改为$k$

  			若无，则在节点表中新建一个节点$k$，标记为$z$

  		重复上述三步
  	
  - 对于数组

  	$t=a[i]\Rightarrow t = d\ \ [\ ] \ \ i,\quad'[\ ]'视为运算符$

  	$d[i] = t\Rightarrow d=i\ \ [\ ]=\ \ t,\quad '[\ ]='视为运算符$

- <span id = "从DAG导出中间代码的启发式算法">**从DAG导出中间代码的启发式算法**</span>

	- 输入：DAG图
	- 输出：中间代码序列
	- 方法：
		- 1、初始化一个放置DAG图中间结点的队列
		- 2、如果DAG图中还有中间节点未进入队列，则执行步骤3，否则执行步骤5
		- 3、选取一个尚未进入队列，但其**所有父节点**均已进入队列的中间节点n，将其加入队列；或选取**没有父节点**的中间节点，将其加入队列（选编号最大的结点，可以避免一些奇怪的问题）
		- 4、如果n的**最左子节点**符合步骤3的条件，将其加入队列；并沿着当前节点的最左边，**循环访问其最左子节点**，最左子节点的最左子节点等，将符合 步骤3条件的中间节点依次加入队列；如果出现不符合步骤3条件的最左子节点，执行步骤2
		- 5、将中间节点队列逆序输出，便得到中间节点的计算顺序，将其整理成中间代码序列

## (四)全局优化

- 和局部优化的区别：局部优化在一个基本块内没有控制流，全局优化处理的是基本块之间的优化受到控制流的影响

### 1、活跃变量分析（Liveness）

- 了解变量x在某个执行点p是活跃的
	
	- 变量x的值在p点或沿着从p出发的某条路经中会被使用， 则称x在p点是活跃的
- 活跃变量信息对于寄存器分配，不论是全局寄存器分配还是临时寄存器分配都有重要意义
	- 如果拥有寄存器的变量x在p点开始的任何路径上不再活跃，可以释放寄存器
	- 如果两个变量的活跃范围不重合，则可以共享同一个寄存器

- 活跃变量分析的数据流方程
	- $in[S] = use[S]\cup(out[S]-def[S])$
		- $out[B] = \bigcup_{B的后继基本快P}in[P]$
		- $def[B]$：变量在B中被定义（赋值）先于任何对它们的使用
		- $use[B]$：变量在B中被使用先于任何对它们的定义
	- 活跃变量分析的数据流：沿流图中控制流的反方向计算

- <span id = "基本块的活跃变量数据流分析（基本思路：迭代）">**基本块的活跃变量数据流分析（基本思路：迭代）**</span>

	- 输入：程序流图，且基本块的$use$集和$def$集已计算完毕
	- 输出：每个基本块入口和出口处的$in[B]$和$out[B]$

	- | 算法：                                                       |
		| ------------------------------------------------------------ |
		| $\mathrm{for\quad each\ \ B\ \ do\quad in[B]=\{\};}$<br />$\mathrm{while\quad 集合in发生变化\quad do}$<br />$\mathrm{\quad for\quad each\ \ B\quad do}$<br />$\mathrm{\quad \quad out[B] = \bigcup_{B的后继基本快P}in[P]}$<br />$\mathrm{\quad \quad in[S] = use[S]\cup(out[S]-def[S])}$<br />$\mathrm{\quad end \\ end}$ |

### 2、全局死代码删除

### 3、可达定义分析（reaching def）

- 通过到达定义分析，希望知道：
	- 在程序的某个静态点p（例如某个代码、基本块）执行前后）
	- 某个变量可能出现的值都是在哪里被定义的？
- 代码对应的到达定义数据流方程
	- `d1: u = v op w， v和w为变量，op为操作符`
	- $out[d1]=gen[d1]\cup(in[d1]-kill[d1])$
		- $gen[d1]=\{d1\}$：表明该语句产生了一个定义点（定义点 d1定义了变量u）
		- $kill[d1]$：是程序中所有对变量u定义的其他定义点的集合（包括d1之前或之后的定义点）
		- 对于该代码在同一基本块中紧邻的后继代码，假设 其为$d2$，$in[d2]$等价于$out[d1]$

- 基本块B的到达定义数据流方程
	- $out[B]=gen[B]\cup (in[B]–kill[B])$
	  - $in[B]$为进入基本块时的数据流信息
	  - $kill[B]= kill[d1] \cup kill[d2]…\cup kill[dn], d1~dn$依次为基本块中的语句
	  - $gen[B]= gen[dn]\cup (gen[d(n-1)] – kill[dn])\cup \\ (gen[d(n-2)] – kill[d(n-1)] – kill[dn])…\cup (gen[d1] - kill[d2] – kill[d3]…- kill[dn])$
- 此处的语句均为块内的语句
	
- <span id = "算法：基本块的到达定义数据流分析（迭代思想）">**算法：基本块的到达定义数据流分析（迭代思想）**</span>

	- 输入：程序流图，且基本块的$kill[\ ]$和$gen[\ ]$已经计算完毕
	- 输出：每个基本块入口和出口处的in和out集合，即$in[B] $和$out[B]$

	- 算法：
		- 1、将包括代表流图出口基本块$B_{exit}$的所有基本块的$out$集合， 初始化为空集
		- 2、根据方程$in[B] = \bigcup_{B的后继基本快P}out[P]$，$out[B] = gen[B]\cup( in[B] – kill[B] )$，为每个基本块$B$依次计算集合$in[B]$ 和$out[B]$
		- 3、如果某个基本块计算得到的$out[B]$与该基本块此前计算得出的$out[B]$不同，则循环执行步骤2，直到所有基本块的$out[B]$集合不再产生变化为止

### 4、全局复制传播（常量传播）

- 目的：寻找所有可以被替换成常量的变量。

### 5、冲突图

- 假设只有跨越基本块活跃的变量才能分配到全局寄存器 并且活跃范围重合的变量之间无法共享全局寄存器
- 连线多画了，不影响程序的正确性； 少连线了，会影响程序的正确性
- 冲突图中两个节点（变量）间存在边的条件约束为：其中一个变量在另一个变量的**定义点**处活跃

- **关于变量冲突的判断**
	- 算法一：在每一个变量的定义点计算活跃变量
	- 算法二：计算基本块入口处的活跃变量（in的集合），这些变量在该基本块中的定义点活跃，因而冲突。之后，在基本块内部，进一步计算每个定义点的活跃变量（基本块范围内计算）
- **Define-use链**
	- 变量的某一定义点，以及所有可能使用该定义点所定义变量值的使用点所组成的一个链
	- 同一变量的多个定义-使用链，如果它们拥有某个同样的使用点，则合并为同一个网

### 6、支配属性（Dominance Property）

- 节点D支配节点N：如果从开始到N的每条路径都通过D

- $Dom(D)=\{N | 从开始到 N 的每条路径都通过D\}$

- <span id = "用数据流计算支配属性">**用数据流计算支配属性**</span>

	- 自上向下，数据流计算过程
	- $D(\boldsymbol{n})=\{\boldsymbol{n}\} \cup \bigcap_{\boldsymbol{m} \in \boldsymbol{p r e d s}(\boldsymbol{n})} D(\boldsymbol{m})$

	![](https://s3.uuu.ovh/imgs/2022/12/03/b100eaf1096f6212.jpg)

	![](https://s3.uuu.ovh/imgs/2022/12/03/7c3e652855db9df8.jpg)

- 支配边界：Dominance Frontier

	- X的支配边界$DF(X) =\{Y | 存在一个从X\rightarrow Y 的路径,且Y是这个路径上第一个不被X严格支配的节点\}$

### 7、循环优化

- 循环L 是基本块的集合，满足①强连通； ②有唯一的入口点

- 优化方案

	- 1、循环不变式（Loop invariant）代码外提（code motion）

	- 2、循环展开（Loop Unroll）
		- 将构成循环体的代码（不包括控制循环的测试和转移部分），重复产生许多次（这可在编译时确定），而不仅仅是一次，以空间换时间
	- 3、归纳变量的优化和条件判断的替换
		- 在每一次执行循环迭代的过程中，若某变量的值固定增 加（或减少）一个常量值，则称该变量为归纳变量 (induction variable)。

## (五)常见的编译优化

![](https://s3.uuu.ovh/imgs/2022/12/03/d15e79e083ae4498.jpg)

# 十二、目标代码生成

##(一)<span id = "指令集架构">指令集架构</span>

- ![](https://s3.uuu.ovh/imgs/2022/12/03/fd7dbeb63bcb8b14.jpg)

	![](https://s3.uuu.ovh/imgs/2022/12/03/9e53a320be0b8755.jpg)

## (二)地址空间

- 略

## (三)寄存器的分配和指派

- 寄存器特点
	- 访问快
	- 有些寄存器和指令执行有关系
	- 数量少，分配策略
- 寄存器分配的目标
	- 将变量与寄存器之间建立对应关系
	- 从程序优化的角度来说，我们希望所有指令的执行都仅在寄存器中完成
- 寄存器通常分为
	- 通用寄存器
		- 保留寄存器
		- 调用方保存的寄存器——临时寄存器
		- 被调用方保存的寄存器——全局寄存器
	- 专用寄存器
- 全局寄存器分配
	- “全局”相对于“基本块”而言，不是“程序全局”
	- 全局寄存器分配的对象主要是函数的局部变量，包 括函数入口参数
- 分配原则
	- 优先分配给跨基本块仍然活跃的变量，尤其是循 环体内最活跃的变量
	- 局部变量参与全局寄存器分配
		- 为了线程安全，全局变量/静态变量一般不参与全局 寄存器分配

### 1、寄存器分配：引用计数

- 原则：如果一个局部变量被访问的次数较多， 那么它获得全局寄存器的机会也较大

### 2、寄存器分配：线性扫描

- 原则：先来先服务，没错就是你想的那个最朴素的分配办法

### 3、<span id = "寄存器分配：图着色算法">寄存器分配：图着色算法</span>

- 一种启发式图着色算法：Chaitin-Briggs算法
	- 输入：冲突图G
	- 算法：
		- 1、找到第一个连接边数目小于K的结点，将它从图G中移走，形成图G’
		- 2、重复步骤1，直到无法再从G’中移走结点
		- 3、在图中选取适当的结点，将它记录为 “不分配全局寄存器”的结点，并从图中移走
		- 4、重复上述步骤，直到图中仅剩余1个结点
		- 5、按照结点移走的反向顺序将点和边添加回去，并分配颜色

### 4、寄存器分配：临时寄存器分配

- 临时寄存器的管理方法：寄存器池
- 分配算法（基本思想 FIFO）
	- 进入基本块：清空临时寄存器池
	- 全局变量、局部变量使用临时寄存器：向临时寄存器池申请
	- 申请处理：
		- 有空闲寄存器：分配申请，做标识
		- 没有空闲寄存器：（启发式）选取一个在即将生成代码中不会被使用的寄存器写回相应的内存空间，标识该寄存器被新的变量占用，返回该寄存器
	- 退出基本块（或函数调用发生前）：将寄存器池中的值写回内存，清空临时寄存器池

## (四)指令选择

- 略

