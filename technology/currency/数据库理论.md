---
title: 数据库理论
mathjax: true
date: 2022-11-17 23:55:19
tags:
categories:
cover:
---

# 零、关于

# 一、概述

## (一)数据管理技术发展的三个阶段

- 人工管理阶段
- 文件系统阶段
- 数据库系统阶段

### 1、文件系统的特点与缺点

- 特点：
	- 1、数据以文件形式保留在外存上
	- 2、文件多样化
	- 3、数据的存取基本上以记录为单位
	- 4、程序和数据有一定的独立性
	- 5、文件与应用程序基本上是一一对应，数据共享性差， 冗余度大

- 缺点：
	- 文件分散、相互独立，数据冗余度大，数据和程序缺乏独立性
		- 存储空间浪费
		- 容易造成数据的不一致性
		- 数据维护难度大
		- 程序维护工作量大

### 2、数据库系统数据管理的特点

- **面向全组织的复杂的数据结构**
	- 在描述数据时，不仅描述数据本身，还要描述数据之 间的联系，使整个组织的数据结构化

- **数据冗余度小，易扩充**
	- 数据库从整体观点描述数据。数据不再面向 某个应用，而是面向整个系统，从而大大减小数据的冗余度
	- 数据库数据的应用可以有很灵活的方式，可以取整体数据的各种合理子集用于不同的应用系统，并可以根据应用需求的变化，重新选取不同子集

- **具有较高的数据和程序的独立性**
	- **数据独立性**：
		- 数据的物理独立性：数据的存储结构（物理结构）改变时，数据的逻辑结构可以不变，从而应用程序也不必改变；
		- 数据的逻辑独立性：数据的逻辑结构改变时，应用程序可以不变
	- 数据库系统提供了两方面的映象（转换）功能
		- 数据的存储结构与逻辑结构之间的映像——实现数据的物理独立性
		- 数据的全局逻辑结构与某类应用所涉及的局部逻辑结构之间的映像——实现数据的逻辑独立性
- **统一的数据控制功能**
	- 数据的安全性控制：保护数据以防止不合法的使用所造成数据的泄密和破坏
	- 数据的完整性控制：指数据的正确性与相容性
	- 并发控制：对多用户的并发操作进行控制、协调，保护数据的完整性
	- 数据库恢复：将数据库从错误状态恢复到某一已知的正确状态

- **数据的最小存取单位是数据项**
	- 既可以存取一个或一组记录，也可以数据库中某个或一组数据项

## (二)数据模型

- 数据模型用来抽象和表示现实世界中的数据和信息

### 1、概念模型

- 概念模型基于信息世界的主要概念，表达应用 中的各种语义（信息）; 具有较强的语义表达能力，能够方便、直接表 达应用中的各种语义; 概念模型应该简单、清晰、易于理解; 概念模型最常用的表示方法： 实体—联系方法（E-R）法

- **基本概念**：
	- 实体（Entity）：客观存在并可相互区分的事物； 
	- 属性（Attribute）：实体所具有的某一特性； 
	- 码（Key）：唯一标识实体的属性集； 
	- 域（Domain）：某个（些）属性的取值范围； 
	- 实体型（Entity Type）：表示一类实体，用实体名及其属性名集合来抽象、刻画
	- 联系（Relation）：实体型之间的联系，是实体之间的相互关联

### 2、数据模型

- 数据模型是严格定义的概念集合。这些 概念精确地描述系统中数据的静态特性、 动态特性和完整性约束

####(1) 数据模型的三要素：

- **数据结构**

	- 数据结构由描述数据对象以及对象之间联 系的一组概念组成。包括：

		- 描述对象的类型、内容、性质的概念，如关系模型中的域、属性等；

		- 描述对象之间联系的概念，如关系模型中的关系；

	- 是数据静态特性的描述；

	- 数据结构是刻画数据模型最重要的方面； 通常按照数据结构的类型来命名数据模型

- **数据操作** 

	- 是对数据库中各种数据对象（型）的实 例（值）允许执行的操作集合，包括操 作及操作规则； 
	- 定义操作的确切含义、操作符号、操作 规则及操作语言； 
	- 是数据动态特性的描述； 
	- 数据库主要有检索和更新（插、删、改）两大类操作

- **完整性约束**

	- 是完整性规则的集合。完整性规则是给 定的数据模型中数据及其联系所有的制 约和依存规则，用以保证数据的正确、 相容
	- 完整约束条件包括： 
		- 符合这种数据模型所必须遵守的基本的通用的完整性约束条件； 
		- 针对具体数据的特定语义约束条件。

#### (2)数据模型分类（层次、网状、关系）及每种模型的特点

##### ①层次模型

- 数据结构是有向树。节点代表实体型，连线表示两实体型间的一对多联系
- 特征：
	- 有且仅有一个结点没有双亲
	- 其它结点有且仅有一个双亲
- 优点：
	- 结构简单，易于实现。
- 缺点：
	- 支持的联系种类太少，只能直接表示二元一对多联系。
	- 数据操纵不方便，子结点的存取只能通过父结点来进行。

##### ②网状模型

- 数据结构是有向图。节点代表实体型，连线表 示两实体型间的一对多联系
- 特征：
	- 可有一个以上的结点没有双亲
	- 至少有一个结点有多于一个的双亲
- 特点：
	- 表达的联系种类丰富
	- 结构复杂

##### ③关系模型

- 用二维表格结构（关系）表示实体及实体之间的联系
- 特点：
	- 用关系描述实体及实体间的联系。这种描述一致性使数据结构大大简化，概念简单。
	- 可直接表示多对多联系。
	- 关系必须是规范化关系。即每个分量是不可分的数据项，或不许表中套表。
	- 关系模型是建立在数学概念基础上，有较强的理论基础

## (三)数据库系统结构

### 1、三级模式体系结构构成及其优点

![](https://s3.uuu.ovh/imgs/2022/12/10/c97583d233e6a0a5.jpg)

#### (1)模式

- 也称为**逻辑模式**、**概念模式**，是数据库中**全体数据的逻辑结构和特性的描述**。是所有用户的公共数据视图；
- 是三级模式的核心。不涉及数据物理存储细节，与具体的应用程序与编程语言无关
- 具体定义数据的逻辑结构（数据记录结构、数据之 间的联系）、数据安全性、完整性要求
- 数据库系统提供模式描述语言（模式DDL， Data Description Language ）进行模式定义。用模式 DDL写出的一个数据库逻辑定义的全部语句，称为 某个数据库的模式。

#### (2)外模式

- 也称为子模式或用户模式。是个别用户的数据视图，即与**某一应用有关的数据的逻辑表示**

- 通常是模式的子集。不同应用的外模式可以相互覆盖，一个应用只能启用一个外模式
- 数据库系统提供外模式描述语言（外模 式DDL）定义外模式。外模式DDL和用 户选用的程序设计语言具有相容的语法

#### (3)内模式

- 也称为存储模式，是数据在数据库系统内部的表示，即对**数据的物理结构和存储方式的描述**
- 内模式通常用内模式数据描述语言（内模式DDL）来描述和定义

#### (4)优点

- 保证数据的独立性
	- 模式与内模式分开——数据物理独立性
	- 外模式与模式分开——数据逻辑独立性
- 简化用户接口，方便用户使用
	- 用户只按照外模式操作，无需了解数据库的总体逻 辑结构与物理存储结构。
- 有利于数据共享
	- 从模式产生不同的外模式，外模式间可相互覆盖。
- 有利于数据的安全保密
	- 应用程序只能操作其对应的外模式

### 2、两级映像

- 外模式/模式映象定义某个外模式与模式 之间的对应关系。当模式改变时，外模式 /模式映象做相应改变，可以保证外模式 不变。——数据的逻辑独立性
- 模式/内模式映象定义数据逻辑结构与存 储结构之间的对应关系。当内模式改变时， 模式/内模式映象做相应修改，使得模式 保持不变。——数据的物理独立性

### 3、DBMS的主要功能

- 1、**数据库定义功能**
	- 提供DDL语言描述外模式、模式、内模式 （源模式）。
	- 模式翻译程序把源模式翻译成目标模式，存入数据字典中
- 2、**数据存取功能**
	- 提供DML语言（Data manipulation language）对数据库进行检索、插入、修 改、删除。
- 3、**数据库运行管理**
	- 并发控制、存取控制、完整性约束条件检查和执行（安全性控制），日志组织和管理，事务管理和自动恢复
- 4、**数据组织、存储和管理**、
	- 用户数据、索引、数据字典的组织、存储和 管理，包括文件结构、存取方式、数据之间联系的实现等
- 5、**数据库的建立和维护功能**
	- 数据的装入、转换，数据库的转储、恢复、 性能监视和分析等。

### 4、DBS的组成

- 1、**语言编译处理程序**
- 2、**系统运行控制程序**
	- 包括系统总控、存取控制、并发控制、完整性控制、 保密性控制、数据存取和更新、通信控制等程序
- 3、**系统建立和维护程序**
	- 数据装入、数据库系统恢复、性能监督、工作日志 等程序
- 4、**数据字典**（import）
	- 也称为数据目录或系统目录，由一系列表组成，存 储着数据库中有关信息的当前描述，包括数据库的 三级模式、用户名表、用户权限等信息。

# 二、关系数据库

## (一)关系模型

### 1、关系模型的数据结构

- 关系模型的数据结构—关系
	- 实体及实体之间的联系均用单一的数据结构—“关系” 来表示
- 几个基本概念
	- 关系、域、n目关系、元组、属性
	- **码（Key,键）**
		- 侯选码（Candidate key）：关系中的某一**属性组**，若它的值**唯一地标识**了一个元组，并具有**最小性**，则称该属性组为侯选码
		- 主码(Primary key,首码，码）：若一个关系有多个侯选码， 则选定其中一个为主码
	- **主属性与非主属性**
		- **码**中的诸属性称为主属性，不包含在任何候选码中的属性称为非主属性。
- 关系模式
	- 关系的描述称作关系模式，它可以形式化地表示为
		- $R（U，D，dom，F， I）$
		- $U$为组成该关系的属性名集合
		- $D$为属性集$U$所来自的域
		- $dom$为属性向域的映象集合
		- $F$为属性间的数据依赖关系集合
		- $I$为完整性约束集合
	- 关系模式通常可以简记作$R(A1 , A2 ,…, An )$，$R$为关系名，$ A1 , A2 ,…, An$为属性名，$D$和$dom$直接说明为属性的类型、长度
	- 关系是关系模式在某一时刻的状态或内容。关系模式是相对稳定的。而关系是动态的，是随时间不断变化的
- 关系数据库（关系数据库的型和值的概念）
	- 关系模式的集合构成关系数据库模式——关系数据库的型
	- 关系的集合则构成具体的关系数据库——关系数据库的值

### 2、关系模型的完整性约束

- 实体完整性（Entity Integrity）

	- 要有属性或属性组合作为主码，主码值不可为空或部分为空。或定义为若属性A是关系R的主属性，则属性A不能取空值。

- 参照完整性（Referential integrity）

	- 外部码

		- 设F是基本关系R的一个或一组属性，但不是R的码。如果F 与基本关系S的主码Ks相对应，则称F是关系R的外部码 （Foreign Key），并称R为参照关系（Referencing Relation），S为被参照关系（Referenced Relation）或目标关系（Target Relation）。R和S不一定是不同的关系。

		- 目标关系S的主码Ks和参照关系的外部码F必须定义在一个域上。

	- 参照完整性

		- 如果关系R的外部码F~k~与关系S的主码P~k~相对应，则R中的每 一个元组的F~k~值或者等于S中某个元组的P~k~值，或者为空值

- 用户定义完整性
	- 用户针对具体的应用环境定义的完整性约束条件

### 3、关系的性质

- 列是同质的（Homogeneous）即每一列中的分量来自同 一域，是同一类型的数据
- 不同的列可出自同一域，每列必须有不同的属性名;
- 列的顺序无所谓，即列次序可以互换;
- 任意两个元组不能完全相同
- 行的顺序无所谓，即行次序可以互换;
- 每一分量必须是不可再分的数据（可简单理解为不可以表中套表）。满足这一条件的关系称作满足第一范式（1NF）的

## (二) 关系运算的数学基础

### 1、关系运算的分类

- 常规集合运算：并、差、交、广义笛卡儿积 （乘）
- 特有的关系运算：选择、投影、连接、自然连接、求商

### 2、关系代数的基本运算与核心运算

#### (1)基本运算

- 并（Union)

	$R\cup S表达为 R\cup S =\{ t |t\in R\or t\in S\}$

- 差（Difference)

	$R-S表达为R−S =\{t | t\in R\and t\notin S\}$

- 交（Intersection)

	$R\cap S表达为R\cap S =\{ t | t\in R \and t\in S\}$

- 广义笛卡儿积（Extended cartesian product）

	$R\times S 表达为R\times S=\{ t | t=< r , s > \and r\in R \and s\in S \}$

#### (2)核心运算

- 选取或限制（Selection or Restriction）

	- 定义：在关系R中选择满足给定条件的元组。记作： 

		$\sigma_F(R)=\{t | t \in R , F(t) =True\}$

		- $F$是选择的条件，取逻辑值“真”或“假”。
		- $F$由运算对象（属性名、常数、简单函数），运算符，包括算术比较符和逻辑运算符连接起来的表达式组成

- 投影（Projection)

	- 定义：从关系R(U)中取若干属性列并删去重复 行，组成新的关系。记作：

		$\Pi_{\mathbf{A}}(\mathbf{R})=\{\mathbf{t}[\mathbf{A}] \mid \mathbf{t} \in \mathbf{R}, \mathbf{A} \subseteq \mathbf{U}\}$

- 连接(Join)

	- 定义：关系R和S在属性X和Y上的连接（X、Y是连接 属性，即X、Y包含同等数量的属性，且相应的属性 均具有共同的域），是从两个关系的广义笛卡儿积 RxS中选取给定属性(X和Y)间满足$\theta$比较条件的元组。 记作：

		$\underset{X \theta Y}{R \bowtie S}=\{\mathbf{t} \mid \mathbf{t}=<\mathbf{r}, \mathbf{s}>\wedge \mathbf{r} \in \mathbf{R} \wedge \mathbf{s} \in \mathbf{S} \wedge \mathbf{r}[\mathbf{X}] \theta s[\mathbf{Y}]\}$

	- $\bowtie$是连接运算符；$\theta$是算术比较运算符， 该连接也称为$\theta$连接

- 自然连接（Natural Join）

	- 定义：关系R与关系S的自然连接，是从两个关系的 广义笛卡儿积RXS中选取在相同属性列上取值相等的 元组，并去掉重复的属性列。记作：R$\bowtie$S, 或R*S

		$R \bowtie S=\{(\mathbf{Z}, \mathbf{X}, \mathbf{W}) \mid(\mathbf{Z}, \mathbf{X}) \in \mathbf{R} \wedge(\mathbf{W}, \mathbf{X}) \in \mathbf{S} \wedge \mathbf{r}[\mathbf{X}]=\mathrm{s}[\mathbf{X}]\}$

	- 连接与自然连接：在等值（ $\theta$取“ =”）连接情况下， 连接属性X和Y是相同属性时，R与S的连接称为自然 连接。自然连接的结果要在上述R与S的等值连接结果 基础上再进行投影运算，去掉重复的属性列

- 除法

	- 定义：设关系R（X，Y）与关系S（Z），其中Y和 Z具有相同的属性数，且对应属性出自相同域。关系R除以关系S所得的商关系是关系R在属性X上投影的一个子集，该子集和 S(Z)的笛卡儿积必须包含在R(X，Y)中

		$\mathbf{R} \div \mathbf{S}=\left\{\mathbf{t} \mid \mathbf{t} \in \Pi_{\mathbf{x}}(\mathbf{R}) \wedge \mathbf{s} \in \mathbf{S} \wedge<\mathbf{t}, \mathbf{s}>\in \mathbf{R}\right\}$

**从数学角度，基本关系代数运算有5种：并、 差、乘、选择、投影** 

**数据库角度，核心的关系代数运算为：选择、投影、连接（或自然连接）**

### 3、 简单元组演算的表达

- 元组关系演算的基本结构是元组演算表达式。元组关系表达式的形式定义：$\{ t |\Phi (t)\}$， 表示了所有使$\Phi$为真的元组的集合，即表示了一个关系

- 其中：

	- t为元组变量。如果元组变量前有“全称”（$\forall$）或 “存在”（$\exist$）量词，则称其为约束元组变量，否则称为自由元组变量。 
	- $\Phi(t)$是元组关系演算公式，由原子公式和运算符组成， 简称公式。

- **递归定义**

	- 原子命题函数是公式，称为原子公式。**原子公式**有三类：
		- $R (t)$。t是关系R中的一个元组。
		- $t[ i ] \theta u[ j ]$。$t[ i ]$与$u[ j ]$分别为$t$的第$i$个分量和$u$的第$j $个分量，它们之间满足比较关系$\theta$ 。
		- $t[ i ] \theta c$或$c \theta t[ i ]$ 。分量$t[ i ]$与常量$c$之间满足比较关系$\theta$
	- 如果$\Phi_1$, $\Phi_2$是公式，则$\Phi_1\and \Phi_2, \Phi_1\or\Phi_2,\neg\Phi_2$也是公式

	- 如果$\Phi$是公式，则$\exist t(\Phi)$和$\forall t(\Phi)$也是公式
	- 在元组演算公式中，各种运算符的优先次序为
		- 算术比较运算符最高
		- 量词次之，且$\exist$的优先级高于$\forall$
		- 逻辑运算符最低，且$\neg$优先级高于$\and$， $\and$高于$\or$
		- 如果有括号，则括号中的运算优先级最高
	- 按照上述4个规则对元组公式进行有限次复合， 可以得到元组演算的所有公式。
- 用关系演算表达五种基本运算:
- 并: $\mathbf{R} \cup \mathbf{S}=\{\mathbf{t} \mid \mathbf{R}(\mathbf{t}) \vee \mathbf{S}(\mathbf{t})\}$
	- 差: $R-S$ $=\{\mathbf{t} \mid \mathbf{R}(\mathbf{t}) \wedge \boldsymbol{\neg} S(t)\}$
	- 卡儿积:
	$\mathbf{R} \times S=\left\{t^{(n+m)} \mid\left(\exists u^{(n)}\right)\left(\exists v{ }^{(m)}\right)(R(u) \wedge S(v) \wedge t[1]=u[1] \wedge \ldots \wedge t[n]=\right.$ $u[n] \wedge t[n+1]=v[1] \wedge \ldots \wedge t[n+m]=v[m])\}$
	- 投影:
	$\prod_{i_1, i_2, \cdots, i_k}(R)=\left\{t^{(k)} \mid(\exists u)\left(R(u) \wedge t[1]=u\left[i_1\right] \wedge \ldots \wedge t[k]\right.\right. = u_i[k])\}$ 
- 选取: $\sigma_F(R)=\left\{t \mid R(t) \wedge F^{\prime}\right\}, F^{\prime}$ 是 $F$ 用 $t[i]$ 代替原运算对象$i$得到的等价公式。

# 三、关系数据库标准语言SQL

- 

# 四、数据库保护

## (一)数据安全性保护

### 1、数据库安全性的含义

- 数据库的安全性是指保护数据库以防止不合法的使用所造成的数据泄漏、更改和破 坏。它包括两个方面的含义：
	- 向授权用户提供可靠的信息服务
	- 拒绝对数据的非授权存取访问请求，保证数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益

### 2、数据库系统安全性控制的手段或机制

- **用户标识与鉴别**
	- 用户标识和认证是系统提供的最外层安全保护措施
		- 标识是指系统采用一定的方式标识其用户或应用程序的名字或身份
		- 认证是指系统在用户或应用程序登录时判断其是否为合法的授权用户
		- 常用的方法是采用用户名和口令
- **存取控制**
	- 存取控制确保合法用户按照指定的权限使用 DBMS和访问数据，而非法用户或不具有相关权限的用户则不能
	- 存取控制机制主要包括两个部分：
		- 用户权限定义：将用户权限记录到数据字典中，形成安全规则或授权规则
		- 合法权限检查，每当用户发出数据库操作请求后， DBMS根据数据字典中的安全规则进行合法权限检查， 决定是否接受用户的操作请求
		- 用户权限定义和合法权限检查机制一起组成了DBMS 的安全子系统
- **视图机制**
	- 为不同的用户定义不同的视图，可以将用户对 数据的访问限制在一定的范围内
- **审计**
	- 把用户对数据库的所有操作都自动记录下来放 入审计日志中。DBA可以利用审计跟踪的信 息，重现导致数据库现有状况的一系列事件， 找出非法存取数据的人、时间和内容等;
- **数据加密**
	- 防止数据库中数据在存储和传输中失密。加密 的基本思想是根据一定的算法将原始数据（明 文）变换为不可识别的格式（密文），从而使 得不知道解密算法的人无法获知数据的内容

### 3、数据存取控制方法基本概念

#### (1)自主存取控制

- 自主存取控制(discretionary access control， 简称DAC)：用户对于不同的数据对象拥有不同的存取权限， 不同的用户对同一对象也有不同的权限，而且用户还可以将其拥有的权限转授给其他用户

- 根据预先定义的用户权限进行存取控制。用户权限是指 用户对数据对象允许执行的操作类型，由数据对象和操 作类型两个要素组成 
- 对于用户存取权限的定义称为授权。在授权中应指明：用户 名，数据对象名，允许的操作类型

#### (2)强制存取方法

- 强制存取控制(mandatory access control， 简称MAC)：每一个数据对象被标以一定的密级，每一个用 户也被授予某一个级别的许可证。对于任一个 对象，只有具有合法许可证的用户才可以存取
- 在MAC中，DBMS所管理的全部实体被分为主体和客体两类
	- 主体 是系统中的活动实体，既包括DBMS所管理的实 际用户，也包括代表用户的各进程、
	- 客体 是系统中的被动实体，是受主体操纵的，包括文 件、基本表、索引、视图等
- 对于主体和客体，DBMS为他们每个实例指定一 个敏感度标记(Label)。敏感度标记被分为若干级 别，如绝密、机密、秘密、公开等。主体的敏感 度标记称为许可证级别，客体的敏感度标记称为密级
- MAC机制通过对比主体的Label和客体的Label，最终确定主体是否能够存取客体。
- 某一主体以某一许可证级别注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：
	- 仅当主体的许可证级别**大于或等于**客体的密级时，该主体才能**读取**相应的客体
	- 仅当主体的许可证级别**等于**客体的密级时，该 主体才能**写**相应的客体

### 4、SQL中存取控制功能

- SQL中可以授予用户两类权限：
	- 用户级权限：
		- 是数据库管理员为每个用户授予的特定权限，是对用户使用整个数据库权限的限定。与整个数据库相关，与数据库中具体的关系无关
	- 关系级权限
		- 是数据库管理员或数据库对象的拥有者为用户授予的与关系或视图有关的权限。这种权限是对用户使用关系和视图权限的限定
- 角色与用户组
	- 为了管理数据库特权的方便，数据库还支 持角色和用户组的概念
	- 角色是一组权限的集合，可以把它授予用户或其他角色。当把某个角色授予用户（或角色） 或从用户（或角色）处收回时，就同时授予或 收回了该角色代表的全部权限
	- 用户组是一组具有相同特性用户的集合。在授权或收回权限时，可以以用户组为单位进行
- 在SQL语言中，通过`Grant`语句授予用户用户级权限或角色
- 当要取消一个用户或角色的权限时，可以使用`Revoke`语句将其收回

## (二)数据完整性保护

### 1、数据完整性的含义

- 数据完整性是指数据的**正确性和相容性**
	- 正确性是指数据应具有合法的类型，并在有效的取值范围之内
	- 相容性是指表示同一个事实的两个数据应该相同

- 数据**完整性**控制是为了防止数据库中存在**不符合语义**的数据，防止错误信息的输入和输出
- 数据**安全性**控制是保护数据库防止恶意的**破坏和非法存取**

### 2、完整性约束条件

- 施加在数据库数据之上的语义约束条件称为数据库完整性约束条件。数据库系统依据完整性约束条件进行完整性检查

- 完整性约束条件作用的对象可以是**列、元组、关系**三种

	- 列约束主要是列的类型、取值范围、精度等约束条件；
	- 元组约束是元组中各个字段间联系的约束
	- 关系约束是若干元组间、关系之间的联系的约束

- 关系模型中的三种完整性约束条件

	![](https://s3.uuu.ovh/imgs/2022/12/10/274b63a8ce832d3b.jpg)

### 3、完整性约束条件分类

- 完整性约束可分为静态约束和动态约束
	- 静态约束是指数据库在每一确定状态数据对象所应满足的约束条件，它是反映数据库状态合理性的约束。
	- 动态约束是指数据库从一种状态转变为另一种 状态时，新、旧值之间所应满足的约束条件， 它是反映数据库状态变迁的约束

#### (1)静态约束

- **静态列级约束**是对一个列的取值域的说明， 包括对数据类型（包括数据类型、长度、 单位、精度等）、数据格式、取值范围或 取值集合、空值等的约束。
- **静态元组约束**规定了组成一个元组的各个 列之间的约束关系。
- **静态关系约束**规定了一个关系的若干元组或者若干关系之间常常存在的各种联系或约束。包括：实体完整性约束、参照完整性约束、函数依赖、统计约束等

#### (2)动态约束

- **动态列级约束**是修改列定义或列值时应满足的约束条件
- **动态元组约束**指修改元组值时元组中各个字段间需要满足的约束
- **动态关系约束**是加在关系变化前后状态上 的限制条件

### 4、**完整性控制**

- **数据库完整性控制**应包括三个方面的功能：
	- **定义功能**，提供定义完整性约束条件的机制
	- **检查功能**，检查用户发出的操作请求是否违背了完整性约束条件
	- **违约响应**，若违背了完整性约束条件，则采取一定措施来保证数据的完整性
- 完整性检查的时机
	- 立即执行约束：立即执行约束是指在执行用户事务的过程中， 在一条语句执行完后立即进行完整性约束的检 查。若违背了完整性约束，系统将拒绝该操作
	- 延迟执行约束：是指在整个用户事务执行完毕后， 再进行完整性约束的检查，结果正确方能提交。 否则系统将拒绝整个事务
- 完整性规则的表示
	- 一条完整性规则可以用一个五元组 $( D，O， A，C，P ) $来描述，其中：
		- D ( Data ) 约束所作用的数据对象
		- O ( Operation ) 触发完整性检查的数据库操作
		- A ( Assertion ) 数据对象必须满足的断言或语 义约束
		- C ( Condition ) 选择A作用的数据对象值的谓 词
		- P ( Procedure ) 违反完整性规则时触发的过程

### 5、SQL完整性支持功能

#### (1)CREATE TABLE 语句

- 语句

	```sql
	Create Table <表名> (
		<列名><数据类型>[<列级完整性约束>] 
		[{,<列名><数据类型>[<列级完整性约束>]}] 
		[{, [<表级完整性约束>]}]
	); 
	```

- 完整性约束

	```sql
	NULL/NOT NULL
	UNIQUE
	PRIMARY KEY
	FOREIGN KEY
	CHECK
	```

#### (2)断言

- 语句

	```sql
	CREATE ASSERTION <断言名> <CHECK子句>
	```

- 定义涉及多个表或统计操作的比较复杂约束

- 任何对断言中所涉及关系的操作都会出发断言检查，使 断言不为真的操作将被拒绝

#### (3)触发器

- 触发器（Trigger)是用户定义在关系上的 一类由事件驱动的特殊过程

- 对于用户对表的更新操作，系统自动激活 相应触发器，执行完整性控制

- 定义触发器

	```sql
	CREATE TRIGGER <触发器名称>
		{BEFORE|AFTER}<触发器事件> ON <表名>
		REFERENCING NEW | OLD ROW AS <变量>
		FOR EACH {ROW|STATEMENT}
		[WHEN <触发条件>]
		<触发动作体>
	```


# 五、关系数据理论

## (一)函数依赖

### 1、函数依赖基本概念

- 设$R(U)$是属性集$U$上的关系模式。$X$、$Y$是$U$的子集。 $r$是$R$的任意一个具体关系，$t$ , $s $是$r$中任意两个元组。如果$t[X] = s[X]$， 则$t[Y] = s[Y]$，则称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作：$ X→Y$

- 函数依赖$X→Y$也可定义为： 对于$X$的每个具体值，$Y$有唯一的值与之对应，则称“$X$函数确定$Y$”或“$Y$函数依赖于$X$"

- 函数依赖相关术语

	- 平凡与非平凡的函数依赖
		- 对于函数依赖$X→Y$，若$Y \subseteq X $，则称$X→Y$是**平凡**的函数依赖；若$Y \not\subseteq X$ ，则称$X → Y$是**非平凡**的函数依赖

	- 决定因素
		- 对于函数依赖$X→Y$，则X叫做决定因素

- 三种函数依赖

	- 完全函数依赖与部分函数依赖
		- 定义：在$R(U)$中，如果$X→Y$，且对于任意$X $的真子集$X '$ ，都有$X ' \not→Y $，则称$Y$对$X$完全函数依赖，记作$X \overset{
			f}{→} Y$ ，否则称为$Y$对$X$部分函数依赖，记作$X \overset{b}{→} Y$

	- 传递函数依赖
		- 定义：在$R(U)$中，如果$X→Y$，$Y → Z$，且$ Y \not→ X$，则称Z对X传递函数依赖，记作$X \overset{t}{→} Z$

### 2、关系键的形式定义

- 侯选码（键）与主码（键）
	- 定义：设$K$为$R< U , F >$中的属性或属性组合， 若$K\overset{f}{→}U$，则称$K$为$R$的候选码。若侯选码多于 一个，则选定其中的一个作为主码。
	- 码的性质： 
		- 唯一性：唯一地标识关系中的元组。 
		- 最小性：若抽去主码中的任意一属性，则主码将失去标识的唯一性
- 主属性与非主属性： 包含在任何一个侯选码中的属性，叫主属性。 不包含在任何码中的属性称为非主属性

- 外部码 
	- 定义：关系模式$R$中属性或属性组$X$并非$R$的码，但$X$是另一个关系模式的码，则称$X$是$R$的外码。
- **候选码的求法**
  - 第1 步,求关系模式R < U , F > 的最小函数依赖集F
  - 第2 步, 按照上面的定义, 分别计算出UL ,UR , UB （UL 表示仅在函数依赖集中各依赖关系式左边出现的属性的集合; UR 表示仅在函数依赖集中各依赖关系式右边出现的属性的集合;另记UB = U - UL - UR ）
  - 第3 步,若UL ≠Φ,计算UL的闭包，若UL+ = U ,则UL 为R 的唯一的候选码,算法结束. 若UL+ ≠U ,转第4 步. 若UL = Φ,转第5 步.
  - 第4 步,将UL 依次与UB 中的属性组合,利用上述的定义判断该组合属性是否是候选码; 找出所有的候选码后,算法结束.
  - 第5 步,对UB中的属性及属性组合利用上述的定义依次进行判断;找出所有的候选码后,算法结束.
  - 简而言之：取最小依赖集，计算UL闭包，如果UL闭包包含全属性，则UL为唯一侯选码，如果不包含，则依次与UB属性组合后再求闭包是否包含全属性。（UL为空时，直接取UB依次组合求闭包）


### 3、函数依赖公理系统

#### (1)函数依赖的逻辑蕴涵

- 定义：关系模式$R< U, F >$中，$X$、$Y$是$R$的属性集合，如果从$F$中的函数依赖能够推出$X→Y$，则 称F逻辑蕴涵$X→Y$

- 函数依赖集F的闭包
	- 定义：在关系模式$R< U, F >$中，为$F$所逻辑蕴涵的函数依赖的全体称作$F$的闭包，记作$F^+$

#### (2)Armstrong公理系统

- 内容：对于$R$ ，有如下规则：
	- $A1$自反律：若$Y \subseteq X \subseteq U$， 则$X → Y$为$F$所蕴含。
	- $A2$增广律：若$X → Y$为$F$所蕴含，且$Z \subseteq U$则$XZ → YZ $为$F$所蕴含
	- $A3$传递律：若$X → Y$， $Y → Z$为F所蕴含，则$X → Z$为$F$所蕴含
- Armstrong公理的推论
	- 合并规则：由$X → Y$，$ X → Z$，有$X → YZ$。
	- 伪传递规则：由$X → Y$， $WY→Z$， 有$WX→Z$
	- 分解规则：由$X → Y$及$Z \subseteq Y$，有$X → Z$
- 从合并规则和分解规则得出如下定理
	- $X→A_1A_2...A_k$成立$\Longleftrightarrow X→A_i$成立$(i=1,2,...,k)$

#### (3)属性集的闭包

- 属性集$X$关于函数依赖集$F$的闭包
	- 定义： 在$R<U,F>$中，$X \subseteq U$

​			$X_F^+ = \{A | X→A能由F根据Armstrong公理导出\} $称$$X_F^+$$为属性集$X$关于函数依赖集$F$的闭包

- 定理： $X →Y$能够由$F$根据Armstrong公理导出 $\Longleftrightarrow Y\subseteq X_F^+$

- **闭包的计算**
	$$
	\require{enclose}
	\enclose{box}{
	    \begin{align}{}
	    	&input:X,F\\
	        &output: X_F^+\\
	        &X_F^+=x\\
	        &do\\
	        &for\quad any\ \ A\subseteq F\quad do\\
	        &\quad if\quad 在F中存在函数依赖 A→B \\
	        &\quad\quad  X_F^+ =  X_F^+ \cup B\\
	        &while (X_F^+发生变化且X_F^+\neq U）
	    \end{align}
	}
	$$
	

### 4、函数依赖集等价与覆盖

#### (1)函数依赖集等价

- 函数依赖集$F$，$G$，若$F^+= G^+$，则称$F$与$G$等价

- 如果$F$和$G$等价，则称$F$覆盖$G$，同时$G$也覆盖$F$。 
	- $F^+ = G^+ \Longleftrightarrow F \subseteq G^+ ，G \subseteq F^+$

#### (2)函数依赖集的最小依赖集

- 最小依赖集

	定义：若函数依赖集F满足下列条件，则称$ F$为一个极小函数依赖集，也称为最小依赖集或最小覆盖:

	-  $F$中任一函数依赖$X → A$，$A$必是单属性。 **（右部单属性化）**
	- $F$中不存在这样的函数依赖$X → A$，使得$F$与 $F - \{X → A\}$等价。**（没有多余的FD）**
	- $F$中不存在这样的函数依赖$X → A$，在$X$中有真子集$Z$，使得$F$与$F - \{X → A\} \cup \{Z → A\}$等价。 **（每个FD左部没有多余属性）**

- **函数依赖集F的极小化处理（算法）**

	- 定理：每个函数依赖集$F$均等价于一个极小函 数依赖集$Fm$，此$Fm$为$F$的最小依赖集

	- 算法：

		- 逐个检查$F$中各函数依赖$FD_i:X→Y$，若$Y=A_1 A_2...A_k,k≥2$，则用${X→Ai |i=1,2,…k}$ 代替$X→Y$。

		- 逐个检查$F$中各函数依赖$X→A$， 设$X = B_1...B_m$， 逐个考查$B_i$，若$A \in (X-B_i)_F^+$ ，则以$(X − Bi)$取代$X$。直到$F$不再改变。

		- 逐个检查$F$中各函数依赖$X→A$，令$G = F−\{X→A\}$， 若$A\in (X)_G^+ $，则从$F$中去掉该函数依赖，直到$F$不再改变。

## (二)范式

### 1、范式的概念

- 如果一个关系满足某个指定的约束集，则称它属于某种特定的范式（Normal Form）
- 满足最低要求约束的称为第一范式，简称1NF, 当一个关系只包含原子值这一约束时，称为1NF。 原子值即为二维表的每一行和列的交叉位置上总是精确地存在一个值，而不是值集。也就是不能 “表中有表”
- 满足“原子值”这一约束条件的关系称为规范化 关系，简称范式。在关系数据库中，都是规范化的关系。

- 各级范式间的联系： $1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF$

- 一个低一级范式的关系模式，通过模式分解可以 转换为若干个高级范式的关系模式的集合，这一 过程称作规范化

### 2、2NF

- 定义：若$R\in 1NF$，且每个非主属性完全依赖于码，则称$R\in 2NF$

- 注意：

	- 如果关系$R$的全体属性都是$R$的主属性，那么 $R\in 2NF$；
	- 从$1NF$中消除非主属性对码的部分函数依赖， 则可获得$2NF$关系
	- 在2NF中，允许主属性部分函数依赖于码

- 采取**投影分解**方法，消除$UN$中的非主属性对码 的部分函数依赖

	![](https://s3.uuu.ovh/imgs/2022/12/11/ee444301e79f9e94.jpg)

- 2NF存在的弊病
	- **插入异常**有所改善，但还是存在
	- **删除异常**
	- **数据冗余**得到一定改善

### 3、3NF

- 定义：关系模式$R< U , F >$中，若不存在这 样的码$X$，属性组$Y$及非主属性$Z(Z\not\subset Y)$， 使得下式成立$X→Y , Y→Z , Y→X ,$ 则称$R\in3NF$

​		或定义为： 若关系模式$R\in 2NF$，且每个非主属性都**不传递依赖**于$R$的任何码，则$R\in 3NF$

- 采用**投影分解**的方法，将SDM规范到3NF		![](https://s3.uuu.ovh/imgs/2022/12/11/996728739d204f3c.jpg)

- 3NF的不完善
	- 3NF没有限制主属性对码的部分与传递函数依赖。如果发生这些依赖，仍可能存在插入异常、删除异常、 修改异常

### 4、BCNF

- 定义： 若关系模式$R< U , F >\in 1NF$，如果对于$R$的每个函数依赖$X→Y$，且$Y\not\subseteq X$时，$X$必含有码，则$R< U , F >\in BCNF$。
	- 所有非主属性都完全函数依赖于每个候选码
	- 所有主属性都完全函数依赖于每个不包含它的候选码
	- 没有任何属性完全函数依赖于非码的任何一组属性

## (三)多值依赖与第四范式

### 1、多值依赖

- 定义：设$R(U)$是属性集$U$上的一个关系模式，$X、Y、Z$ 是$U$的子集，并且$Z = U – X – Y$，关系模式$R(U)$中多值依 赖$X →→ Y$成立，当且仅当对$R(U)$的任一关系$r$，给定的 一对$(x，z)$值有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关

- 形式化定义：在$R(U)$的任一关系$r$中，如果存在元组$t.s$ 使得$t[X]=s[X]$，那么就必然存在元组$w,v∈r,(w,v 可以与s,t相同)$，使得：

	- $w[X] = s[X] = v[X] = t[X]$
	- $w[Y] = t[Y]，v[Y] = s[Y]$
	- $w[Z] = s[Z]， v[Z] = t[Z]$

	则称$Y$多值依赖与$X$，记作$X →→ Y$

- 多值依赖的性质
	- 若$X→→ Y$，则$X →→ Z$，其中$Z=U-X-Y$
	- 若$X →→ Y$，而$Z= \empty$，则称$X →→ Y$为平凡的多值依赖， 否则， 若$X →→ Y$，而$Z \neq \empty $，则称$X →→ Y$为非平凡的多值依赖。
	- 若$X →→ Y$， $X →→ Z$，则 $X →→ YZ$
	- 若$X →→ Y$， $X →→ Z$，则 $X →→ Y\cap Z$
	- 若$X →→ Y$， $X →→ Z$，则 $X →→ Y-Z$，$ X →→ Z-Y$
	- **函数依赖是多值依赖的特殊情况**

### 2、4NF

- 定义：关系模式$R< U , F > \in 1NF$，如果对于R的每个非平凡 的多值依赖$X→→Y（Y\not\subseteq X）$，$X$都含有码，则称$ R\in 4NF$

	4NF所允许的非平凡的多值依赖实际上是函数依赖 （左部含有码的）。 4NF就是限制关系模式的属性之 间不允许有非平凡且非函数依赖的多值依赖

	或定义：

	- 关系模式$R\in BCNF$，且不存在非平凡的非函数依赖的多值依赖，则$R\in 4NF$
	- 含义：若$R\in BCNF$，当R中只存在函数依赖，则$R\in 4NF$；或当R中存在平凡的多值依赖时，$R\in 4NF$

- 非4NF的关系存在的弊病是数据冗余太大

![](https://s3.uuu.ovh/imgs/2022/12/11/56afabeface5daba.jpg)

## (四)模式分解理论

- 函数依赖集合$F_i = \{X→Y | X→Y\in F^+ \and XY \subseteq U_i\}$，称$F_i$为$F$在$U_i$上的投影
- 关系模式$R<U.F>$的一个分解$\rho$是指
	- $\rho = \{R_1<U_1,F_1>,R_2<U_2,F_2>,...,R_n<U_n, F_n>\}$
	- 其中$U = \bigcup_{i=1}^{n}U_i$，并且没有$U_i \subseteq U_j,1≤i,j ≤n$，$F_i$是$F$在$U_i$上的投影

### 1、分解的无损连接性

- 设$\rho = \{R_1,R_2,...,R_n\}$是$R$的一个分解，$r$是$R$的一个关系，定义 $m_\rho (r) = \bowtie_{i=1}^k \prod_{Ri}(r)$，其中

​		$\Pi_{R i}(r)=\left\{t\left[U_i\right] \mid t \in r\right\}$, 即 $m_\rho (r)$是 $r$ 在 $\rho$ 中各关系模式投影上的连接。若对于 $\mathbf{R}<\mathbf{U}, \mathbf{F}>$ 的任何一个关系 $r$, 都有 $r=m_\rho(r)$, 则称分解 $\rho$ 且有无损连接性, 简称 $\rho$ 为无损分解。

- **无损分解的判定算法**
	$$
	\begin{aligned}
	& \rho=\left\{\mathbf{R}_1<\mathbf{U}_1, \mathbf{F}_1>, \mathbf{R}_2<\mathbf{U}_2, \mathbf{F}_2>, \ldots, \mathbf{R}_{\mathbf{k}}<\mathbf{U}_{\mathrm{k}}, \mathbf{F}_{\mathbf{k}}>\right\}, \\
	& \mathbf{U}=\left\{\mathbf{A}_1, \mathbf{A}_2, \ldots, \mathbf{A}_{\mathbf{n}}\right\}, \mathbf{F}=\left\{\mathbf{F D}_1, \mathbf{F D}_2, \ldots \mathbf{F D}_{\mathbf{p}}\right\}, \mathbf{F D}_{\mathrm{i}} \text { 为 } \\
	& \mathbf{X}_{\mathrm{i}} \rightarrow \mathbf{A}_{\mathrm{i}}, \mathbf{X}_{\mathrm{i}} \subseteq \mathbf{U}
	\end{aligned}
	$$
	

	- 1、建立 $n$ 列 $k$ 行的表 $T B$ :

		- 每一列对应一个属性 $\mathbf{A}_{\mathrm{i}}$;

		- 每一行对应分解中的一个关系模式 $R_i$ 。

		- 分量的取值： $\mathbf{C}_{\mathrm{ij}}=\left\{\begin{array}{l}\mathbf{a}_{\mathrm{j}}, \mathbf{A}_{\mathrm{j}} \in \mathbf{U}_{\mathbf{i}} \\ \mathbf{b}_{\mathrm{ij}}, \mathbf{A}_{\mathbf{j}} \notin \mathbf{U}_{\mathbf{i}}\end{array}\right.$

	- 2、对FD $D_i$ 中每一个函数咏赖 $X \rightarrow Y$, 若 $T B$ 中存在元 组 $t_1, t_2$, 使得 $t_1[X]=t_2[X]$, 则对每一个 $A_i \in Y_{:}$ 

		- (1) 若 $t_1\left[A_i\right], t_2\left[A_i\right]$ 中有一个等于 $a_i$, 则另一个也改为 $a_i$
		- (2)若(1)不成立, 则取 $t_1\left[A_i\right]=t_2\left[A_i\right]\left(t_1\right.$ 的行号小于 $\left.t_2\right)$ 

	- 3、及复执行2, 直至:

		- (1)TB 中出现一行为 $\mathbf{a}_1, \mathbf{a}_2, \ldots, \mathbf{a}_{\mathbf{n}}$ 的一行。
		- (2) TB不再发生变化, 且设有一行为 $\mathbf{a}_1, \ldots, \mathbf{a}_{\mathrm{n}}$ 。
			在(1)情况下, $\rho$ 为无损分解, 否则为有损分解。

	- 例

		![](https://s3.uuu.ovh/imgs/2022/12/11/98d76139d4842113.jpg)

- 无损分解的判定准则
	- 定理： $\mathrm{R}<\mathrm{U}, \mathrm{F}>$ 的一个分解 $\rho=\left\{R_1<\mathrm{U}_1\right.$, $\left.F_1>, R_2<U_2, F_2>\right\}$ 具有无损连接性的充分必要条件是 $U_1 \cap U_2 \rightarrow U_1-U_2 \in \mathbf{F}^{+}$或 $\mathbf{U}_1 \cap \mathbf{U}_2 \rightarrow$ $\mathbf{U}_2-\mathbf{U}_1 \in \mathbf{F}^{+}$。
		- 即 $R_1, R_2$ 的共同属性至少构成 $R_1 、 R_2$ 二者之 一的侯选码。

### 2、分解的保持函数依赖性

- 定义: 若 $\mathbf{F}^{+}=\left(\cup_{i=1}^n \mathbf{F}_{\mathrm{i}}\right)^{+}$, 则称 $\mathbf{R}<\mathbf{U}, \mathbf{F}>$ 的分解 $\rho=$ $\left\{\mathrm{R}_1<\mathrm{U}_1, \mathrm{~F}_1>, \ldots, \mathbf{R}_{\mathrm{n}}<\mathrm{U}_{\mathrm{n}}, \mathrm{F}_{\mathrm{n}}>\right\}$ 保持函数依赖。
- 保持函数依赖性的判定方汯
设 $G=\left(U_{i=1}^n F_i\right)$, 则
$\mathbf{F}^{+}=\mathbf{G}^{+} \Leftrightarrow \mathbf{F} \subseteq \mathbf{G}^{+}$, 且 $\mathbf{G} \subseteq \mathbf{F}^{+}$
要判定 $F \subseteq \mathbf{G}^{+}$, 只需逐一对 $F$ 中函数依赖 $X \rightarrow Y$, 考察 $Y$ 是 否属于 $X_G^{+}$。若有 $\mathbf{F}$ 中的函数依赖不满足该条件, 则 $\mathbf{F}^{+}$ $\neq \mathbf{G}^{+}, \rho$ 末保持函数依赖。
- $\mathrm{R}$ 中的每个函数依赖都能够从 $\mathrm{R}_1 \ldots \mathrm{R}_{\mathrm{n}}$ 函数依赖的并集逻辑导出。

### 3、模式分解的原则

- 具有无损连接性
- 保持函数依赖

### 4、关系模式的分解算法

#### (1)达到3NF且保持函数依赖的分解算法

- 1、对 $F$ 进行**极小化处理**, 仍记为 $F$ 。

- 2、找出不在 $F$ 中出现的属性, 将它们构成一个关系模式, 并从$U$中去掉它们(剩余属性仍记为$U$)。

- 3、若有 $X \rightarrow \mathbf{A} \in \mathbf{F}$, 且 $X \mathbf{A}=\mathbf{U}$, 则 $\rho=\{\mathbf{R}\}$, 算法终止。
- 4、对 $\mathrm{F}$ 按具有相同左部的原则进行分组 (设为 $\mathrm{k}$ 组), 每一组函数依赖所涉及的属性全体为 $U_i$, 若有 $U_i \subseteq \mathbf{U}_{\mathbf{j}}$ $(i\neq \mathbf{j}$ ), 则去掉 $U_i$。令$F_i$ 为 $F$ 在 $U_i$ 上的投影, 则 $\rho=\left\{R_1<U_1\right.$, $\left.F_1>, \ldots, \mathbf{R}_{\mathbf{k}}<\mathbf{U}_{\mathrm{k}}, \mathbf{F}_{\mathrm{k}}>\right\}$ 是 $\mathrm{R}<\mathbf{U}, \mathrm{F}>$ 的一个保持函数依赖的分解, 并且每个 $\mathbf{R}_{\mathrm{i}}<\mathrm{U}_{\mathrm{i}}, \mathbf{F}_{\mathrm{i}}>\in \mathbf{3 N F}$ 。

#### (2)达到3NF且同时保持无损连接与函数依赖的分解（这是重点）

- 设 $\rho=\left\{\mathbf{R}_1<\mathbf{U}_1, \mathbf{F}_1>, \ldots, \mathbf{R}_{\mathbf{k}}<\mathbf{U}_{\mathbf{k}}, \mathbf{F}_{\mathbf{k}}>\right\}$ 是 $\mathrm{R}<\mathrm{U}, \mathrm{F}>$ 的一个保持函数依赖的 $3 \mathrm{NF}$ 分解。
- 设 $X$ 为 $R<U, F>$ 的码,
	- (1)若有某个 $U_i, X \subseteq U_i$, 则 $\rho$ 即为所求,
	- (2) 否则令 $\tau=\rho \cup\left\{R^*<X, F_X>\right\}, \tau$ 即为所求。

#### (3)达到BCNF无损连接分解算法

- 给定关系模式 $R<U, F>$,
	- (1) 令 $\rho=\{R<U, F>\}$
	- (2) 检查 $\rho$ 中各关系模式是否属于BCNF, 若是, 则算法终止。
	- (3) 设 $\rho$ 中 $\mathrm{R}_{\mathrm{i}}<\mathrm{U}_{\mathrm{i}}, \mathrm{F}_{\mathrm{i}}>$ 不属 于 BCNF， 则存在函数依赖 $X \rightarrow A \in F_i^{+}(A \notin X)$, 且 $X$ 不是 $R_i$ 的码, 则 $\mathrm{XA}$ 是 $\mathrm{U}_{\mathrm{i}}$ 的真子集, 将 $\mathrm{R}_{\mathrm{i}}$ 分解为$\sigma=\left\{\mathrm{S}_1, \mathrm{~S}_2\right\}$,其中 $\mathbf{U s}_1=\mathbf{X A}, \quad \mathbf{U s}_2=\mathbf{U}_{\mathbf{i}}-\{\mathbf{A}\}$以 $\sigma$ 代替 $R_i$, 返回到 (2)。

# 六、数据库设计

## (一)数据库规范设计方法

- 数据库设计分为以下六个阶段：
	- 需求分析
		- 对应用环境进行详细调查，收集支持系统目标的基础数据及其处理
	- 概念结构设计
		- 通过对用户需求进行综合、归纳与抽象，形成独立于数据库逻辑结构与具体DBMS的概念模型，可以用**ER图**等表示
	- 逻辑结构设计
		- 将概念结构转换为某个DBMS所支持的数据模型，并进行优化。再将得到的逻辑结构转换成特定的DBMS能处理的模式、子模式
	- 物理结构设计
		- 设计数据库在物理设备上的存储结构和存取方法。一般分为两步：一是确定数据库的内模式；二是对物理 结构进行时间与空间效率的评价;
	- 数据库实施
		- 是建立数据库的过程。用DBMS的DDL描述三级模式， 并调试产生目标模式。开发应用程序，组织数据入库并试运行
	- 数据库运行和维护
		- 在数据库正式运行后，由DBA执行对数据库经常性的维护工作，包括数据库转储与恢复、数据库控制、数据库性能监控、数据库的重组与重构

## (二)概念结构设计

### 1、E-R法

- E-R法概述

	- E-R法的思想是用E-R图描述现实世界的信息，这种信息 结构称为概念结构（概念模型），然后根据具体系统的 要求将概念结构转换成特定系统所能接受的逻辑结构 （层次、网状、关系）

	- E-R法由两部分组成:

		- 用E-R图描述现实世界

		- 将E-R图转换成相应的数据模型

			![](https://s3.bmp.ovh/imgs/2022/12/12/920aff59708c8b16.jpg)

- **E-R图**

	E-R图的组成：实体、联系、属性

	- 实体：用长方形表示实体型，在框内写上实体名
	- 属性：用椭圆形表示实体的属性，并用无向边把实体与其属性连接起来
	- 联系：用菱形表示实体间的联系，菱形框内写上联系名。用无向边把菱形分别与有关实体相连，在无向边 旁标上联系的类型。若联系也具有属性，则属性和菱 形也用无向边连接上

	E-R图实体之间联系的语义扩充

	- 存在依赖：子女实体存在依赖于父母实体的存在， 则称子女实体是弱实体
	- 标识依赖：如果实体不能由它自己的属性来唯一标识，而必须通过与它 相联系的另一实体一起来标识 ，那么称该实体标识依赖于另一个实体
	- 实体的子类：子类可继承父类的属性，子类也可以附加某些属性； 子类之间的交不一定为空。

### 2、局部E-R图设计步骤

- 整体步骤：

	- 1、选择局部应用

	- 2、以需求分析中得到的数据元素表为基础， 利用数据抽象机制，建立实体模型

	- 3、确定实体之间的联系类型。用E-R图表示这些实体与实体之间的联系，形成分E-R图

- **局部E-R图中的实体模型设计**

	- 建立实体模型的关键是确定**实体**及其**属性**

	- 实体模型的建立方法
		- 对数据字典进行初步抽象，得到实体和属性，然后再按原则进行必要调整
	- 数据抽象机制
		- **分类**：**定义某一概念作为现实世界中一组对象的类型**。这些对象具有某些共同的特性和行为。如实体型。
		- **聚集**：**定义某一类型的组成成分**。 如属性的聚集组成了实体型
		- **概括**：**定义类型之间的一种子集联系**
	- 实体模型的调整原则
		- 作为属性，不能再具有需要描述的性质。属性必须是**不可分的数据**项，不能是另一些属性的聚集
		- **属性不能与其他实体具有联系**，即E-R图中所表示的联系是实体之间的联系
		- **实体和描述它的属性之间保持1:1或n:1的联系**。对于 1:n 或 n:m联系，要进行调整，一般可将该属性上升为实体

### 3、综合分E-R图形成总E-R图

- 设计总E-R图（全局概念模式）可以有两种方法
	- 多个分E-R图一次集成
	- 逐步集成，用累加的方式一次集成两个分E-R图
- 集成局部E-R图的步骤
	- 合并：解决各分E-R图之间的冲突，将各分E-R图合 并起来生成**初步E-R图**
	- 修改和重构：消除不必要的冗余，生成**基本E-R图**
- 局部E-R图的合并
	- 冲突主要包括：属性冲突、命名冲突和结构冲突
		- 属性冲突：属性的类型、取值范围或取值集合不 同，或属性取值单位冲突
			- 解决——讨论协商解决
		- 命名冲突：包括属性名、实体名、联系名之间的 同名异义，异名同义
			- 解决—— 建立命名表，统一命名，异名同义的名字可标为别名
		- 结构冲突：
			- 同一对象在不同应用中有不同抽象。如在一应用中为实体， 在另一应用中为属性
				- 解决——遵守实体与属性的划分原则，把属性变为实体或实体变为属性， 使同一对象具有相同的抽象
			- 同一实体在不同分E-R图中属性个数、次序不同
				- 解决——同一实体的属性通常取分E-R图中属性的并，再适当调整次序
			- 实体之间的联系在不同分E-R图中呈现不同类型
				- 解决——根据语义加以综合或调整。
- 修改初步E-R图设计基本E-R图
	- 初步E-R图中可能存在冗余的数据和冗余的联系
		- 冗余的数据是指可由基本数据导出的数据
		- 冗余的联系是指可由其它联系导出的联系
	- 消除冗余有两种方法：
		- 分析法
		- 规范化方法
- 规范化方法消除冗余联系
	- 1、把E-R图中实体用符号表示
	- 2、对每一对n:1、1:1或n:m联系表示为实体码之间的函数依赖表达式$X→Y$
	- 3、利用函数依赖集的最小覆盖算法进行极小化处理。设原函数依赖表达式集合为F，最小覆盖集为G，则D=F-G
	- 4、考察D中每一个函数依赖表达式，确定是否冗 余联系
	- 5、去掉冗余联系后形成基本E-R图

## (三)逻辑结构设计

- 逻辑结构设计的任务就是把概念结构转换为选用的DBMS所支持的数据模型的过程

- 关系数据库逻辑结构设计的任务具体包括
	- 形成初始关系数据库模式
	- 关系模式规范化
	- 关系模式优化
	- 子模式定义

### 1、E-R图向关系模型的转换规则

- 一个实体型转换为一个关系模式。实体的属性就是关系的属性，实体的码就是关系的码
- 一个联系转换为一个关系模式。与该联系相连的各实体的码以及联系的属性转换为关系的属性
	- 若联系为1：1，则每个关系的码均是该关系的候选码
	- 若联系为1：n，则该关系的码是n端实体的码
	- 系为n：m，则该关系的码是诸实体码的组合
- 三个或三个以上实体间的多元联系，转换为一个关系模式，与该多元联系相连的各实体的码以及 联系的属性转换为关系的属性，而关系的码为各实体码的组合
- 具有相同码的关系可以合并
- 弱实体类型的转换
	- 对于每个弱实体类型，创建一个新的关系，该 关系中包含所有弱实体类型的属性
	- 把标识关系（被依赖关系）的主码添加到新关 系中，并将其作为新关系的外码
	- 新关系的主码是标识关系的主码和弱实体类型 的部分标识(码）的组合
- 超类/子类联系的转换
	- 为超类和每个子类创建单独的关系
	- 在超类所创建的关系中，包含所有子类成员 都共有的属性，包括主码
	- 在超类中包含一个（或多个）属性作为子类 判定符；
	- 在为每个子类所创建的关系中，包含超类的 主码以及子类特有的属性

### 2、关系模型的规范化与优化

- 规范化：按照数据依赖的理论，逐一分析转换所得关系 模式，判断是否存在部分函数依赖、传递函数 依赖、多值依赖等，确定它们的范式等级

- 优化：按应用系统的处理要求，确定是否进行模式合并或分解

	为了提高存取效率和存储空间的利用率，可以 对关系模式进行必要的分解

	- 水平分解：是把关系的元组分为若干子集合，定义每个子集合为一个子关系，以提高系统效率
		- 80/20原则：可以把经常使用的那一部分数据分解出来作为 一个关系，其他数据作为另一个关系
		- 数据分片：如果关系R上具有n个事务，而且多数事务存取的数据不相交，则R可以分解为少于或等于n个子关系
	- 垂直分解：是把关系模式R的属性分解为若干子集合，形成若干子关系模式
		- 垂直分解的原则是，经常在一起使用的属性从R中 分解出来形成一个子关系模式
		- 垂直分解必须确保无损连接性和保持函数依赖

## (四)数据库的物理设计

- 数据库物理结构包括数据在物理设备上的存储结 构与存取方法
	- 确定数据库的存储结构
	- 选择关系的存取方法：是使事务能够快速存取数据库中数据的技术

### 1、关系的存取方法

- **索引方法**
	- 基本概念
		- 为了加速所需数据的访问
		- 索引记录/索引项，是索引文件的记录，包括两个域
			- 索引域：存储数据文件中一个或一组域的一个值（K）
			- 索引域：存储数据文件中一个或一组域的一个值（K）
	- 常用B+树索引：树中所有关键字都按递增次序从左到右安排在叶节点上， 并且链接起来。B+树能同时进行随机查找和顺序查找
	- 选择索引域原则
		- 经常在查询条件中出现的属性
		- 经常作为最大值和最小值库函数的参数
		- 经常作为连接属
	- 索引并非越多越好
- **聚集方法**
	- 把关系中某个属性/组(聚集键)值相同的记录集 中存放在连续的物理块，称为聚集。能够提高该属性的查询速度
	- 一个关系只能参加一个聚集
	- 聚集存取方法的选择
		- 一般原则
			- 经常进行连接操作的关系可建立聚集
			- 单个关系的某组属性经常进行相等比较
			- 关系的某个属性组值重复率高
		- 注意问题：建立与维护聚集系统开销很大，对于更新操作远远多于连接操作的关系不应使用聚集方法
- **HASH文件**
	- 通过HASH函数将记录关键字转换成地址。
	- 如果关系的属性主要出现在等连接条件中， 或出现在相等比较条件中，而且满足下列条件之一，可以选择该方法：
		- 关系的大小可预知，而且不变
		- 如果关系大小动态改变，则须DBMS提供动态 HASH存取方法

# 七、存储管理与索引

## (一)数据库的存储结构/物理结构

### 1、概述

- 数据库存储结构主要是文件组织结构
- 数据库-文件-块/页
	- 数据库：由若干文件组成，这些文件采用专有的格式。操作系统不能获取这些文件内容的任何信息。
	- 文件：由若干个定长的存储单元/存储块/页构成。
	- 页：存储分配和数据传输的单位
- DBMS中的存储管理器负责维护这些数据库文件，将文件组织为块/页的集合，并且
	- 跟踪页的数据读取/写入
	- 跟踪可用的空间
- 数据库的表被映射为底层存储中的文件
- 一个文件在逻辑上被组织为记录的序列，记录被映射到磁盘块上
- 文件在存储中由若干磁盘块构成，块是存储分配和数据传输的单位
- 一个块可以包含几个记录，每条记录被完全包含在单个块中 。每个记录有唯一的标识符ID(由块号和记录在块中的位置构成)

- 表所占磁盘块的分配方法
	- 连续分配——数据块被分配到连续的磁盘块上
	- 链接分配——数据块中包含指向下个数据块的指针
	- 按簇分配——簇是连续的几个磁盘块，簇之间指针连接
	- 索引分配——索引块中存放指向数据块的指针

### 2、数据库页/块

- 页/块是固定大小的数据块

	- 可以包含元组/记录，元数据，索引，log记录等
	- 每个页有唯一标识符（ID），DBMS将页ID映射为页的物理位置

- 页/块的结构

	- 每个页由头部header和数据构成。
	- Header 包含了页中数据的元数据，例如：页大小，Checksum，DBMS 版本

- 数据库页/块结构

	最常用的结构是分槽(slot)页结构

	- Header记录了已使用的槽数，以及最 后一个被用槽的起始位置偏移量，以 及一个槽数组
	- 槽数组保存了每个元组的起始位置偏移量
	- 增加记录时，槽数组从开始到尾部的方向增长，而记录数据则从数据区的尾部到开始的方向增长。当槽数组与元组数据连接到一起时，认为页满
	- 便于存储变长记录

	<img src="https://s3.bmp.ovh/imgs/2022/12/12/36b8e104b58ff962.jpg" style="zoom:50%;" />

### 3、记录的结构

- 是字节序列，DBMS负责将该序列解释为属性类型和值
	- 记录头部：包含元组的元数据，例如加锁信息等
	- 记录数据：属性的实际数据。属性一般按表定义中 的顺序存储。多数DBMS不允许一个记录大小超过 一个页
- 唯一标识符ID
	- 每个记录被分配了一个ID
	- 最常见的形式：页ID+（offset或槽）
	- 应用程序不能依赖该ID进行唯一性标识
- <img src="https://s3.bmp.ovh/imgs/2022/12/12/364c96c53451053b.jpg" style="zoom:50%;" />

### 4、文件中的记录组织-堆

- 堆文件组织：记录可以存放在文件空间中的任何位置
- 链表方式：在文件开始维护一个header页，该页存储了空白页链表头指针和数据页链表头指针，每个页记录了当前包含的空槽数
- 页目录方式：DBMS维护特殊页保存文件中的数据页的位置，并记录每个页中空槽数
- ![](https://s3.bmp.ovh/imgs/2022/12/12/f29ec2a4bd035135.jpg)

### 5、文件的记录组织-顺序

- 顺序文件组织：文件中的记录按搜索码排序排列
	- 搜索码：用于在文件中查找记录的任意属性或属性集合
	- 通过指针把记录链接起来，每个记录的指针指向按搜 索码排列的下一条记录
	- 可以高效按某个搜索码处理记录
- 有序链表的亚子（

### 6、文件的记录组织-索引

- 索引是指记录的关键字与相应记录的存储地址的对照表
- 索引文件由主文件和索引表构成
	- 索引表必须按关键字有序
	- 主文件本身可以按主关键字有序组织（即索引顺序文件）或 无序组织（即索引非顺序文件）
- 文件的位置任意，索引表是有序链表（

### 7、文件的记录组织-散列

- 散列文件的存储单位称为桶(Bucket) 。桶号可以是相对块号， 最终可以转换为外存空间上的物理地址
- 设计一个哈希函数h以及处理冲突的方法，将记录散列到存储 块上
- 哈希函数将搜索码作为参数，并计算出一个[0,N-1]区间中的整 数，将具有键值k的记录Record(k)存储在对应h(k)编号的桶中 ，一个文件由N个桶组成
- 在散列值的个数多于一个桶时，形成一个主桶和多个溢出桶的列表
- 二次检索：先利用哈希函数h确定项所在的主桶，再根据链表 逐一找到每个溢出桶
- 学过hash的都懂（

### 8、文件的记录组织-聚集

- 具有相同或相似属性值的记录存储于连续的磁盘块中
- 聚集码是一种属性，它定义了哪些记录被存储在一起
- 多表聚集：将多个关系存储于一个文件中，在每个块 中存储两个或更多关系的相关记录.可以加快特定的连 接查询，但会使单个表的访问变慢

## (二)缓冲区管理系统

- 块/页是存储分配和数据交换的单位 
- 缓冲区：是主存中可以存储磁盘块副本的区域 
- 缓冲区管理器：负责缓存空间分配，内外存交换 
- 管理目标：最小化磁盘和主存间传输存储块的数量， 即最小化磁盘存取次数；实现手段是在主存中保持尽量多的块
- 执行引擎需要操作某磁盘块时，通过资源管理 器调用缓冲区管理
	- 如果该块在缓冲区中，则缓冲区管理器返回该块在内存的地址
	- 如果不在缓冲区，则缓冲区管理器为该块在缓冲区 中分配空间（这可能替换某个块，如果被替换的块 修改过，需要将其写回磁盘），将块从磁盘读进缓 冲区，并将内存地址返回给调用者

### 1、缓冲区组织与管理

- 缓冲区被组织为一个固定大小页面数组，每个 元素称为帧，存放磁盘上的一个页/块
- 缓冲区元数据——页表（page table），跟踪当前 内存中所有页的访问情况，并保存了每个页的元数据，包括
	- Dirty Flag：由修改页的线程设置，通知存储管理器 该页必须写回磁盘
	- Pin/Reference计数器:在一页被进 程读写操作前要钉住（pin），防止该 页被移出，操作结束后解除钉（计 数器减1），只有计数器=0时，才 能被移出或写回磁盘
- 缓冲区中的共享锁与排它锁
	- 缓冲区管理器提供封锁系统，允许数据库进程以共享或 排他模式封锁页，在完成操作后释放封锁
	- 实现并发控制，读操作加共享锁，更新操作加排他锁
	- 加锁规则：一次只能由一个进程获得排它锁，共享锁与 排它锁不能同时加，多个进程可以同时持有共享锁
- 缓冲区替换策略
	- 最近最少使用（Least Recently Used）策略及其改进算 法
- DBMS本身也是一个操作系统，内存操作也很类似于一般的操作系统

## (三)索引

### 1、索引的基本概念

- 索引文件构成
	- 索引记录/索引项，是索引文件的记录，包括两个域：
		- 索引域（搜索码）：存储数据文件中一个或一组域（属性）
		- 指针：指向索引域值为K的记录所在磁盘块的地址。
- 索引将表中的部分属性进行组织或排序，使得 DBMS的执行引擎利用这些属性能够快速有效进 行表的访问
- DBMS负责在执行查询时使用最恰当的索引

### 2、索引的分类

- 分类——两种基本类型
	- 排序索引：索引项是排序的
	- 哈希索引：索引项使用索引域上的hash函数确定位置
- 聚集索引与非聚集索引
	- 聚集索引：索引域/搜索码值的排列顺序与记录在文件中的 排列顺序一致，也称为主索引 （primary index ）
	- 非聚集索引：索引项排列的次序与文件中记录的排列顺序不同，也称为辅助索引（Secondary index）
- 稠密索引与稀疏索引
	- 稠密索引：对于文件中 的每个搜索码值都有一 个索引项
	- 稀疏索引：只有部分索引域/搜索码值有索引记录。当 文件记录以索引域排序时，可以采用。
		- 利用稀疏索引查找索引域为k的记录：在索引中定位小于k的最大索引域值，从该索引域指针指向的记录开始顺序查找
		- 相比稠密索引，占空间小并且维护代价低，但定位记 录慢。非聚集索引都是稠密索引
- 多级索引
	- 索引规模大，无法 全部放入内存，导 致性能下降
	- 对索引文件建立稀 疏索引
		- 外层索引：基本索引的稀疏索引
		- 内层索引：基本索引文件

### 3、B树

- B树（平衡树）索引

	- 是附加限制条件的索引树。限制了每个节点放置关键 字与指针的最小和最大个数：根节点有$[2,n]$个子节点， 中间节点有$\lceil n/2, n \rceil$个子节点，叶节点有$\lceil (n–1)/2, n-1 \rceil$个记录指针，$n$值对特定树是固定的
	- 从树根到叶节点每条路径的长度都相同，因此所有的叶节点都在同一层上
	- B树的关键字是散布在各层上

- B+树

	- 是B树的改进。把树中所有关键字都按递增次序从左到右安排在叶节点上，并且链接起来。B+树能同时进行随机查找和顺序查找

	- B+树节点结构

		每个节点最多包含n-1个披索码/索引码 /关键字值 $K_1, K_2 \ldots, K_{n-1}$ 以及n个指针 $P_1, P_2 \ldots, P_n$ 。

		| $P_1$ | $K_1$ | $P_2$ | …    | $P_{n-1}$ | $K_{n-1}$ | $P_n$ |
		| ----- | ----- | ----- | ---- | --------- | --------- | ----- |

		- $\mathbf{K}_{\mathrm{i}}$ 是索引码的值
		- $P_i$ 对于非叶子节点是指向子节点的指针; 对于叶子节点 $P_1, P_2 \ldots$ , , $P_{n-1}$ 是指向记录或记录桶的指针, $P_n$ 指向下个叶子节点
		- 节点中各索引码的值满足:

		$$
		K_1<K_2<K_3<\ldots<K_{n-1}
		$$

	![](https://s3.bmp.ovh/imgs/2022/12/12/fb08dec9b1819dd2.jpg)

- B+树的查询

	- 从树的根节点开始，通过比较查询码值v与节点的ki值，向下遍历树，直到到达包含指定值的叶节点为止。如果在叶子节点中找到ki=v,则返回目标记录指 针pi；否则关系中不存在该值的记录

- B+树的插入

	- 采用查询算法定位插入的叶节点l，如果有空间则插入，否则需要拆分
	- 拆分：将节点l的n个码值的前[n/2] 放在l中，剩下值放在新节点中；将新节点插入l的父节点中。如此自底向上递归处理，直到插入不再产生拆分或建立了一个新根节点为止

- B+树的删除

	- 采用查询算法定位删除的叶节点l进行删除，如果l的码值个数低于下限，可能导致节点合并或重新分配
	- 合并或重新分配：如果删除后节点 l太小，将其与兄弟节点合并 ，并从父节点中删除，如此自底向上递归处理，直到根节点。 如果在合并时，新节点码值数超过上限，则需要该节点与其兄弟节点之间重新分配指针

### 4、Hash索引

- 基于哈希表（Hash table）实现
- 哈希表实现key到value的映射。通过键值映射到表中一 个位置来访问记录，这个映射函数叫做 Hash 函数，存放记录的数组叫做哈希表。
- 哈希表的实现包括两部分
	- 哈希函数：将很大的key空间映射到比较小的域，用于计算桶/槽数组的元素序号；非用于加密算法的哈希函数； 计算速度快且碰撞率低
	- 哈希方案（scheme）：解决一个哈希值对应多条记录。 最常使用溢出链接(Chaining)法
- 静态哈希：哈希表的大小是固定的
	- 文件增大时，太多的溢出桶将降低访问性能
	- 数据规模缩小时，会造成空间浪费
- 动态哈希：允许哈希表的大小动态修改
	- 定期重哈希：创建新的大的哈希表，把原表上的 key重新哈希到新表上
	- 线性哈希：以一种递增的方式重新哈希

# 八、查询处理与查询优化

## (一)关系查询处理步骤

- 查询分析
- 查询检查
- 查询优化
- 查询执行

![](https://s3.bmp.ovh/imgs/2022/12/12/2429d3c8ba104b24.jpg)



## (二)查询操作的实现

### 1、实现查询操作的算法——选择

- 全表扫描法：按照物理顺序读表的M块到内存，检查内存的每个元 组t，如果满足条件则输出t，直到表所有块都经过上述检查
- 索引扫描法：如果在选择条件的属性上有索引，先通过索引找到目标索引项，再通过索引项找到元组

### 2、实现查询操作的算法——排序

- 内存中完全容纳的关系 ，可用快速排序法 (quicksort)等算法；内存中无法容纳的关系，采用外排序——归并算法
- 外排序-归并
	- 第一阶段，建立多个排好序的归并段（run） ，每个段仅包含关系的部分记录
	- 第二阶段对归并段进行归并

### 3、实现查询操作的算法—连接

- 嵌套——循环法：两个连接的表，第一个表为外循环，另一个为内循环
	- 不需要索引，并适用于任何连接条件
	- 需要检查两个关系中的每一对元组，代价高
	- 如果连接操作使用的缓冲区块数为$k$，分配$(k-1)$ 块给外表$r$，$1$块给内表$s$, 则存取块数为：
		- $b_r + b_r/(k-1)*b_s$
		- 其中$b_r$ 为表$r$的块数， $b_s$为表$s$的块数
		- 应选择较小表作为外表
- 索引连接法：第二个表按照连接属性建索引，取第一个表元组的连接属性与第二个表元组的连接属性比较
	- 如果内层关系$s$的连接属性上有索引，则对于外层关系$r$中的每一个元组 $t_r$ ，可以用索引查找$s$中与$t_r$满足连接条件的元组
	- 如果$r$和$s$在连接属性上都有索引，则以元组较少的关系作为外层关系，代价最小
- 排序——合并法：两个表都按照连接属性排序，取第一个表元组的连接属性与第二个表元组的比较
	- 为每个关系分配一个指针，分别为$pr$和$ps$，对于$pr$指向$r$的一个连接属性值，移动$ps$找到$s$中与该值相等的元组，与$pr$指向的元组做连接，如此移动两个 指针分别遍历$r$和$s$
	- 两个关系的每个块都只需要读一次，访问块数：$b_r + b_s$
	- 只能用于等值连接或自然连接
- Hash join法：连接属性作为hash码，用同一个hash函数把两个连接表的元组散列到同一个hash文件
	- 给希函数 $h$ 用于划分两个关系。 $h$ 将连接属性值映射到 $\{0$, $1, \ldots, n\}$ 集合上。将 $\mathrm{r}$ 的元组划分为 $r_0, r_1, \ldots, r_n$ 个部分, 如果 $h\left(t_r[\right. JoinAttrs] )=i$, 则元组 $t_r$ 将被放入 $r_i$, 同理将 $\mathrm{s}$ 也划 分成 $\mathrm{s}_0, s_l \ldots, s_n$ 个部分。
	- 对于某个连接属性值，若被哈希为$i$，则$s$中相应的元组必定在$s_i$中，而$r$中的元组必定在$r_i $中，因此只需将$ s_i$和$r_i $中的元组相比较
	- 适用于等值连接或自然连接

### 4、其他运算的实现算法

- 去重：使重复数据相邻，保留一个数据删除其它 
	- 排序方法 
	- 哈希方法
- 投影：在每个元组上执行投影，之后再去重
- 集合运算——并，差，交
	- 类似排序-合并连接，排序然后对每个已排序的关系扫描一次
	- 类似hash-join将两个关系分区，在两个关系对应区中执行运算
- 库函数
	- 基于分组属性进行排序或散列以聚集同组的元组，再执行库函数

## (三)查询优化

### 1、查询优化目标

- 选择一个高效执行的查询处理策略，使得查询代价 最小，即访问磁盘的块数最少

### 2、代数优化

- 通过对关系代数表达式的等价变换来提 高查询效率
- 关系代数表达式的等价：指用相同的关系代替两个表达式中相应的关 系所得到的结果是相同的

- **关系代数表达式等价变换规则**

	- 1、.连接、笛卡尔积交换律
		$$
		\begin{aligned}
		& \boldsymbol{E}_1 \times \boldsymbol{E}_2 \equiv \boldsymbol{E}_2 \times \boldsymbol{E}_1 \\
		& \boldsymbol{E}_1 \bowtie \boldsymbol{E}_2 \equiv \boldsymbol{E}_2 \bowtie \boldsymbol{E}_1 \\
		& \boldsymbol{E}_1 \bowtie \boldsymbol{E}_2 \equiv \boldsymbol{E}_2 \bowtie \boldsymbol{E}_{\mathrm{F}}
		\end{aligned}
		$$

	- 2、连接、笛卡尔积的结合律
		$$
		\begin{aligned}
		& \left(E_1 \times E_2\right) \times E_3 \equiv E_1 \times\left(E_2 \times E_3\right) \\
		& \left(E_1 \bowtie E_2\right) \bowtie E_3 \equiv E_1 \bowtie\left(E_2 \bowtie E_3\right) \\
		& \left(E_1 \underset{F_1}{\bowtie}  E_2\right)\underset{F_2}{\bowtie}  E_3 \equiv E_1 \underset{F_1}{\bowtie} \left(E_2 \underset{F_2}{\bowtie}  E_3\right)
		\end{aligned}
		$$

	- 3、投影的串接定律
		$$
		\pi_{A_1, A_2, \cdots, A_n}\left(\pi_{B_1, B_2, \cdots, B_m}(E)\right) \equiv \pi_{A_1, A_2, \cdots, A_n}(E)\\
		\{A_1, A_2, \cdots, A_n\}是\{B_1, B_2, \cdots, B_m\}的子集
		$$

	- 4、 选择的串接定律
		$$
		\sigma_{F_1}\left(\sigma_{F_2}(E)\right) \equiv \sigma_{F_1 \wedge F_2}(E)
		$$

	- 5、选择与投影的交换律
		$$
		\sigma_F\left(\pi_{A_1, A_2, \cdots, A_n}(E)\right) \equiv \pi_{A_1, A_2, \cdots, A_n}\left(\sigma_F(E)\right)
		$$

	- 6、选择与笛卡尔积交换律

		- $F$中只有 $E1$的属性: $\sigma_{\mathrm{F}}\left(E_1 \times E_2\right) \equiv \sigma_{\mathrm{F}}\left(E_1\right) \times E_2$
		- $F=F 1 \wedge F 2$, 且 $F 1$ 只有 $E 1$ 的属性、 $F 2$ 中只有 $E 2$ 的属性: $\sigma_F\left(E_1 \times E_2\right) \equiv \sigma_{F_1}\left(E_1\right) \times \sigma_{F_2}\left(E_2\right)$
		- $F1$只有 $E1$的属性, $F 2$ 有 $E1$和$E2$ 的属性:

		$$
		\sigma_{\mathrm{F}}\left(E_1 \times E_2\right) \equiv \sigma_{\mathrm{F}_2}\left(\sigma_{\mathrm{F}_1}\left(E_1\right) \times E_2\right)
		$$

	- 7、选择与并的分配律
		$$
		\sigma_{\mathrm{F}}\left(E_1 \cup E_2\right) \equiv \sigma_{\mathrm{F}}\left(E_1\right) \cup \sigma_{\mathrm{F}}\left(E_2\right)
		$$

	- 8、选择与差的分配律
		$$
		\sigma_F\left(E_1-E_2\right) \equiv \sigma_F\left(E_1\right)-\sigma_F\left(E_2\right)
		$$

	- 9、选择对自然连接的分配律
		$$
		\sigma_{\mathrm{F}}\left(E_1 \bowtie E_2\right) \equiv \sigma_{\mathrm{F}}\left(E_1\right) \bowtie \sigma_{\mathrm{F}}\left(E_2\right)
		$$

	- 10、投影与笛卡尔积的分配律
		$$
		\pi_{A_1, A_2, \cdots, A_n, B_1, B_2, \cdots, B_m}\left(E_1 \times E_2\right) \equiv \pi_{A_1, A_2, \cdots, A_n}\left(E_1\right) \times \pi_{B_1, B_2, \cdots, B_m}\left(E_2\right)
		$$

	- 11、投影与并的分配律
		$$
		\pi_{A_1, A_2, \cdots, A_n}\left(E_1 \cup E_2\right) \equiv \pi_{A_1, A_2, \cdots, A_n}\left(E_1\right) \cup \pi_{A_1, A_2, \cdots, A_n}\left(E_2\right)
		$$

- 优化的一般准则
	- **选择运算尽早执行**。是优化策略中最重要、最基本 的一条。（**减小中间关系-减少元组数据**）
	- **投影运算尽早执行**。**（减小中间关系-减少属性数目）**
	- 把投影运算和选择运算同时进行；把投影同其前或其后的双目运算结合起来。（**减少扫描关系的次数）**
	- 把某些选择同在它前面要执行的笛卡尔积结合起来 成为一个连接运算。**（把笛卡尔积与选择转换为连接）**
	- 找出公共子表达式，把公共子表达式的结果写入中 间文件，重复使用。**（中间结果复用）**
- 查询树的优化
	- 查询树是关系代数表达式的树形表示
		- 操作的关系位于叶节点
		- 关系运算位于内部节点
		- 执行方式：自底向上执行，当一个内部节点的操作 分量可用时，该节点的操作启动执行，执行结束后 用结果关系代替该节点
	- 查询树的构造
		- 将SQL语句转换为关系代数表达式：SELECT子句对应投影操作，FROM子句对应笛卡尔积， WHERE子句对应选择操作
		- 将关系代数表达式转换为查询树
	- **查询树优化算法**
		- 利用规则 4 分解选择运算, 把形如 $\sigma_{F_1 \wedge F_2}(E)$ 变换为 $\sigma_{F_1}\left(\sigma_{F_2}(E)\right)$
		- 利用规则4-9把选择运算尽量移到叶端。
		- 利用规则 $3,5,10,11$ 把投影运算尽量移到叶端
		- 利用规则 3-5把选技和投影的串接合单成单个选技、单 个投影或一个选择后跟一个投影 的形式。使尽可能多的选择和投影同时执行
		- 对每个叶节点加必要的投影操作，以去掉对查询 无用的属性
		- 如果笛卡尔积后还需按连接条件进行选择操作， 可将两者组合成连接操作

### 3、物理优化

- 选择高效合理的操作算法或存取路径，得到优化的查询计划。
- 常用方法
	- 基于规则的启发式优化方法
	- 基于代价估算的优化方法
	- 两者结合的优化方法

#### (1)基于启发式规则的存取路径选择优化

- 选择操作的启发式规则
	- 对于小关系，使用全表顺序扫描
	- 对于大关系：可以采用索引扫描法（如结果的元组 数目较小），全表顺序扫描。
- 连接操作的启发式规则
	- 如果两个表都已经按照连接属性排序——排序-合并法；
	- 如果一个表在连接属性上有索引——索引连接法
	- 如果连接属性上未排序且未建索引，且其中一个表 较小——Hash join法
	- 最后可选用嵌套循环法，并选择较小的表为外循环表

#### (2)基于代价估算的优化

- 利用数据库的统计信息计算各种操作算法的执行代价，选出具有最小代价的执行计划
- 数据库统计信息主要包括:
	- 每个基本表的规模，包括元组数、元组长度、占用 块数以及溢出块数等
	- 基本表每个列的信息，包括不同值个数、最大与最 小值，是否有索引以及索引类型等
	- 索引的具体信息，例如B+树索引的层数、不同索引值个数等\

### 4、查询优化的一般步骤

- 把查询转换成语法树，如关系代数语法树（查 询树）。
- 把查询树利用代数优化转换成优化后的标准形 式。
- 利用基于启发式规则的物理优化，选择底层的 存取路径，生成查询计划；利用基于代价的物 理优化，选择代价最小的

# 九、事务处理技术

## (一)事务

- 事务(Transaction)是用户定义的数据库操作序列，这些操作要么都做，要么都不做， 是一个不可分割的工作单位
- 事务的特性（ACID）：
	- 原子性(Atomicity)：事务中包括的所有操作要么都做，要么都不做
	- 一致性(Consistency)：事务执行的结果必须是使数据库从一个一致性状态，变到另一个一致性的状态
	- 隔离性(Isolation)：一个事务的执行不能被其它事务干扰。即一个 事务内部的操作及使用的数据对其他并发事务 是隔离的，并发执行的各个事务之间不能互相 干扰
	- 持久性(Durability)：一个事务一旦提交之后，它对数据库的影响必 须是永久的。其它操作或故障不应该对其执行 结果有任何影响
- 事务的ACID特性对于数据库数据的正确、 有效具有重要意义。但事务的特性有可能遭破坏，主要有两种情况：
	- 多个事务并行运行时，不同事务的操作交叉进行；
	- 事务在运行过程中被强行停止
- 事务处理技术的作用
	- 利用数据库并发控制机制以及数据库恢复 机制保证事务的特性不被破坏，从而保证 数据库数据的正确、有效

## (二)数据库恢复

- 数据库管理系统必须具有把数据库从错误状态恢复到某一已知正确状态的功能，这就是数据库的恢复
- 数据库恢复是通过数据库管理系统的恢复子系统完成的

- 数据库恢复子系统的意义
	- 保证事务的原子性。实现事务非正常终止时的回滚。
	- 当系统发生故障以后，数据库能够恢复到正确状态。

### 1、数据库系统中故障的种类

- 事务内部的故障
	- 可预期的：事务根据内部的测试条件，确定是否回滚
	- 不可预期的：指不能由应用程序处理的事务故障，如死锁，运算溢出，违反完整性规则等
- 系统故障
	- 是指造成系统停止运行的任何事情，使得系统要重新启动。如硬件错误，操作系统故障，停电等
	- 这类故障打断所有正在运行的事务，使事务都异常中止，但不会破坏数据库。
- 介质故障
	- 介质故障指外存故障，如磁盘损坏，瞬时强磁场干扰等
	- 这类故障将破坏全部或部分数据库，并影响正在存取这部分数据的所有事务
- 计算机病毒
	- 计算机病毒是一种人为的破坏或故障，已成为数据 库系统的主要威胁之一
	- 多数病毒对数据进行非法修改

### 2、恢复的实现技术

- 数据库恢复的基本原理为冗余。即利用存储在系统别处的冗余数据来重建或恢复修正数据库。

#### (1)数据转储

- 是DBA定期地将整个数据库复制到磁带或另一个 磁盘上保存起来的过程。这些备用的数据文本称 为后备副本或后援副本。
- 利用副本进行恢复的基本原理
- ![](https://s3.bmp.ovh/imgs/2022/12/12/b5b442d38e2e31cc.jpg)
- 数据转储分为两种转储状态
	- 静态转储：系统中无事务运行时进行的转储操作。并且转储过程中，不允许对数据库进行任何存取、修改
		- 优点：保证副本的数据一致性
		- 缺点：由于转储必须等待正在运行的事务结束才能开始，而 新的事务必须等待转储结束才能执行，降低了数据库的可用 性。
	- 动态转储：转储期间允许对数据库进行存取或修改。
		- 优点：不影响数据库的可用性
		- 缺点：不能保证副本上的数据正确、有效。还必须把转储期 间各事务对数据库的修改记录下来，建立日志文件。后援副 本加上日志文件就能把数据库恢复到某一时刻的正确状态
- 数据转储可有两种转储方式
	- 海量转储：海量转储指每次转储全部数据库
	- 增量转储：增量转储指每次只转储上一次转储后更新过的数据。

#### (2)日志文件的建立与使用

- 日志文件格式与内容
	- 日志是用来记录事务对**数据库更新操作**的文件。日志文件主要有两种格式：以记录为单位和以数据块为单位
	- 记录为单位的日志文件
	- 记载的内容
		- 各个事务的开始标记
		- 各个事务的结束标记
		- 各个事务的所有更新操作
	- 每个日志记录中包含的信息项
		- 事务标识（标明是哪个事务）
		- 操作的类型（插入、删除或修改）
		- 操作对象（记录的内部标识）
		- 更新前数据的旧值（对插入操作，此项为空）
		- 更新后数据的新值（对删除操作，此项为空）
	- 以数据块为单位的日志文件，日志记录的内容包括事务标 识以及更新前和更新后的数据块
- 日志文件的作用
	- 务故障和系统故障恢复必须使用日志文件。
	- 在动态转储方式中必须建立日志文件，后备副本和 日志文件综合起来才能有效地恢复数据库
	- 在静态转储方式中，用日志文件恢复转储结束时刻 到故障点间的事务
- 日志文件的写入规则
	- 登记的次序严格按并发事务执行的时间顺序
	- 必须先写日志文件，后写数据库

### 3、故障的恢复策略

- **事务故障的恢复——UNDO**，即撤消事务

	在不影响其它事务的情况下，强行回滚，撤消已做的修改：

	- 反向扫描日志文件，查找该事务的更新操作
	- 对该事务的更新操作（插入、删除、修改）执行 逆操作，即将日志记录中的“更新前的值”写入 数据库
	- 如此处理下去，直到读到该事务的开始标志

- **系统故障—— UNDO+REDO**

	- 系统故障造成数据库不一致状态的原因有两个：
		- 一是未完成的事务对数据库的更新可能已经写入数据库
		- 二是已提交事务对数据库的更新可能还留在缓冲区未写入数据库
	- 因此恢复操作就是要撤销(UNDO)故障发生时未完成的事务，重做(REDO)已完成的事务
	- 系统故障恢复具体步骤
		- 正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标识记入重做（REDO）队 列。同时找出故障发生时尚未完成的事务，将 其事务标识记入撤销（UNDO）队列；
		- 对撤销队列中的各个事务进行UNDO处理
		- 对重做队列中的各个事务进行REDO处理

- 介质故障的恢复，恢复的方法：

	- 装入最新的数据库后备副本，使数据库恢复到 最近一次转储时的一致状态。对于动态转储的 副本，还需要装入转储开始时刻的日志文件副 本，将数据库恢复到一致状态
	- 装入转储以后的日志文件副本，重做已经完成 的事务。

### 4、具有检查点的恢复技术

- 利用日志技术进行恢复时，恢复子系统通常需要检查大量日志记录，存在的问题是：
	- 搜索日志耗费大量时间
	- 不必要重做某些事务
- 检查点技术可以改善效率，使得在检查点 之前提交的事务，在数据库恢复处理时不 必重做

#### (1)检查点技术

- 在日志文件中增加检查点（checkpoint）记录

- 检查点记录的内容包括：

	- 建立检查点时刻所有正在执行的事务清单
	- 这些事务最近一个日志记录的地址

- 系统中增加一个重新开始文件，用来记录各个检查点记 录在日志文件中的地址

	![](https://s3.bmp.ovh/imgs/2022/12/12/912e65147d82c628.jpg)

- 恢复子系统动态维护日志文件，即周期性地执行如下操作

	- 将当前日志缓存中的所有日志记录写入磁盘的日志文件上
	- 在日志文件上写入一个检查点记录
	- 将当前数据缓存的所有数据记录写入磁盘的数据库中
	- 将当前数据缓存的所有数据记录写入磁盘的数据库中

#### (2)利用检查点技术进行恢复

- **利用重新开始文件定位最近检查点记录**：在重新开始文件中找到最后一 个检查点记录在日志文件中的地址
- **找到检查点时刻运行事务清单**：由该检查点记录得到检查点建立时刻所 有正在运行的事务清单ACTIVE-LIST，把ACTIVE-LIST 暂时放入 UNDO-LIST
- **确定需要撤消和重做的事务**：从检查点开始正向扫描日志文件，做如下 处理，直到文件结束
	- 如果有新开始的事务Ti，把Ti暂时放入UNDO-LIST
	- 如果有提交的事务Tj ，把Tj从UNDO-LIST队列移入到REDO-LIST 队列
- **执行撤消或重做动作**：对UNDO-LIST中的每一个事务执行UNDO操作 ，对REDO-LIST中的每个事务执行REDO操作



### 5、事务的4个特性在什么情况下会遭到破坏，数据库系统中采用什么技术保证事务的这些特性不被破坏？  

事务的特性分别为：原子性，一致性，隔离性和持续性。  

原子性是指：事务是数据库工作的最基本单位，事务中的诸操作要么全做，要么全不做。  造成 原子性破坏的原因主要是由于程序故障、系统故障和介质故障等。需要由数据库使用日志、转  储等技术实现的恢复机制加以保护。  

一致性是指：事务的执行结果必须使数据库从一个一致性状态变为另外一个一致性状态  造成  一致性破坏的原因是事务的原子性被破坏等，需要使用数据库恢复和完整性约束机制来加以保  护。  

隔离性是指一个事务的执行不能被其他事务干扰。造成隔离性被破坏的原因主要是事务的并发  执行所产生的错误。需要利用并发控制机制，如封锁、锁协议等加以保护。  

事务的持续性是指，一个事务一旦被提交，它对数据库中数据的改变就是永久的。  造成持续性  被破坏的原因主要是原子性遭到了破坏，需要使用数据库恢复机制加以保护。

## (三)并发控制

### 1、并发控制的必要性

- 丢失更新(Lost Update)：两个事务T1和T2读入同一数据并修改， T2提 交的结果破坏了T1提交的结果，导致T1的修 改被丢失
- “脏”数据的读出(Dirty Read)：事务T1修改某一数据，并将其写回磁盘，事务T2读 取同一数据后，T1由于某种原因被撤销，这时T1已 修改过的数据恢复为原值，T2读到的数据就与数据 库中的不一致，则T2读到的数据就为“脏”数据。
- 不能重复读(Non-Repeatable Read)：事务T1读取数据后，事务T2执行更新（修改、插入、 删除）操作，使T1无法再现前一次读取的结果。

### 2、并发控制的原理

- 并发控制基本思想
	- 并发控制就是要合理调度并发事务，避免 并发事务之间的互相干扰造成数据的不一 致性
	- 并发控制的主要方法是采用封锁机制
- 并发控制的基本手段
	- 封锁就是事务T在对某个数据对象如表、 记录等操作之前，先向系统发出请求，对 其加锁，从而对该数据对象有了一定的控 制权
	- 基本的封锁有两种类型：
		- 排它锁（X锁，eXclusive lock）：事务T对数据对象R加上 X锁，则只允许T读取和修改R，其它事务 对R的任何封锁请求都不能成功，直至T释 放R上的X锁。
		- 共享锁（S锁，Share lock）：事务T对数据对象R加上S 锁，则事务T可以读取但不能修改R，其它 事务只能对R加S锁，而不能对R加X锁， 直到T释放R上的S锁

### 3、封锁协议

- 运用X锁和S锁这两种基本封锁，可以建立 不同的约定，形成不同级别的封锁协议， 以保证事务并发执行过程中的数据的一致 性。

#### (1)一级封锁协议—— 防止丢失修改

- 协议内容：事务T在修改数据R之前必须对其加X锁， 直到事务结束才释放。事务结束包括正常结束 (COMMIT)和非正常结束(ROLLBACK)
- 一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。 但在一级封锁协议中，不要求读数据操作对数据加锁，因此它不能保证可重复读和不读“脏”数据

#### (2)二级封锁协议—— 防止读“脏”数据

- 协议内容：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁
- 级封锁除了防止丢失更新，还可以进一步防止读“脏”数据。但由于读完后即可释放S锁，所以不能保证可重复读

#### (3)三级封锁协议—— 保证数据可重复读

- 协议内容：一级封锁协议加上事务T在读取R之前必须 对其加S锁，直到事务结束才释放
- 三级封锁协议除了防止丢失修改和读“脏”数据以外， 还进一步防止了不可重复读

![](https://s3.bmp.ovh/imgs/2022/12/12/a492d68bec49aacf.jpg)

## (四)粒度封锁与意向锁

### 1、封锁的粒度

- 封锁对象的大小称为封锁粒度。
- 封锁对象：属性值、属性值集合、元组、关系、某索引 项、整个索引、整个数据库、物理页、块等
- 封锁粒度大，则并发度低，封锁机构简单，开销小
- 封锁粒度小，则并发度高，封锁机构复杂，开销高
- 多粒度封锁：在一个系统中同时支持多种封锁粒度供不同的事务选择。选择封锁粒度时应同时考虑封锁开销和 并发度两个因素，适当选择封锁粒度以达到最优效果

### 2、多粒度封锁

- **多粒度树**的根结点是整个数据库，表示最大的粒度。叶结点表示最小的粒度

- 多粒度封锁协议

	- 多粒度封锁协议允许多粒度树中的每个结点被独立地加锁。对一个结点加锁意味着这个结点的所有后裔结 点也被加以同样类型的锁。因此，在多粒度封锁中一 个数据对象可能以两种方式封锁，即：

		- **显式封锁**是应事务的要求直接加到数据对象上的封锁

		- **隐式封锁**是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁。

	- 在多粒度封锁方法中，显式封锁与隐式封锁的效果是一样的

- 多粒度封锁中存在的问题

	- 在多粒度封锁方法中，一般对某个数据对象加 锁，系统要做如下检查：
		- 是否与该数据对象上的显式封锁冲突（检查对象本身）
		- 是否与该数据对象上的隐式封锁冲突（检查对象的所有上级结点）
		- 是否与该数据对象下级的显式封锁冲突（检查其所有下级结点）

### 3、意向锁

- 意向锁的含义是该结点的下层结点正在被加锁
- 对任意节点加锁时，必须先对其上级节点加意向锁
- 意向锁的好处是：在对象加锁时，不再检查下级结点的封锁，只需检查对象和它的上级结点
- 三种常用的意向锁：
	- 意向共享锁（Intent Share Lock，简称IS锁）：如果要对一个数据对象加IS锁，表示它的后裔结点拟（意向） 加S锁
	- 意向排它锁（Intent Exclusive Lock ，简称IX锁）：如果要对一个数据对象加IX锁，表示它的后裔结点拟（意向） 加X锁
	- 意向共享排它锁（ Share Intent Exclusive Lock ，简 称SIX锁）：如果要对一个数据对象加SIX锁，表示对它加S锁，再加IX锁， 即SIX=S+IX
- 具有意向锁的多粒度封锁方法中，任意事务T要对一个数据对象加锁，要先对它的上级对象结点加意向锁，申请封锁按自上而下的次序进行；释放封锁时，应按自下而上的次序进行
- ![](https://s3.bmp.ovh/imgs/2022/12/12/629074e1c20cd756.jpg)

### 5、活锁与死锁

- 预防死锁
	- 一次封锁法
		- 要求每个事务必须一次将其所有要使用的数据全部 加锁，否则就不能执行
		- 可以有效地防止死锁的发生，但由于需要扩大加锁 的范围，因此降低了系统的并发度
	- 顺序封锁法
		- 预先对数据对象规定一个封锁顺序，所有的事务都 要按照这个顺序实行封锁
		- 可以有效地防止死锁，但由于数据库中数据的不断 变化和事务封锁要求的动态提出而实现难度大
- 死锁的检测
	- 超时法：如果一个事务的等待时间超过了规定的期限，就认为发生了死锁
	- 等待图法：事务等待图是一个有向图G=(T, U),其中T为结点集合，每个结点表示正在运行的事务，U为边集，每条边表示事务的等待情况。 并发控制子系统周期性的检测事务等待图，如果发现图中存在回路，则表示系统出现死锁
- 死锁恢复
	- 通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁，使其他事务得以继续运行下 去。对于所撤销的事务所作的操作必须加以恢复

### 6、事务的调度

- N个事务的一个**调度**S是N个事务所有操作 的一个序列S ，表示这些操作的执行顺序。 并且这个序列满足：对于每个事务T，如 果操作 i 在事务T中先于操作k执行，则在S 中操作 i 也必须先于操作 k 执行
- 串行调度与并行调度
- 事务并发调度的正确性
	- 对并发事务中操作的调度是随机的，而不 同的调度可能产生不同的结果，但**调度要保证事务执行的正确性**
	- 事务执行正确性的含义
		- 一个事务正常的或者预想的结果是没有其它并行事务干扰时得到的结果。因此**一组事务的串行调度策略一定是正确的调度策略**
		- 虽然不同的串行顺序的结果会不同，由于**各种结果都将保持数据库数据的一致性，所以都是正确的。**

- 并发调度的可串行性
	- 可串行化：多个事务的并发执行是正确的，当且仅当其结 果与按某一次序串行执行它们时的结果相同， 我们称这种调度策略为可串行化调度
	- 可串行性是并行事务正确性的准则：**一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度**
	- **两段锁协议**(Two-phase Locking)可保证并行事务的可串行性
		- 两段锁协议的内容
			- 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。
			- 在释放一个封锁之后，事务不再获得任何其它封锁。

		- 两段锁协议的含义：事务分为两个阶段，第一个阶段是获得封锁，也称为**扩展阶段**；第 二个阶段是释放封锁，也称为**收缩阶段**。

- 可串行化调度的判定
	- 一个调度$Sc$在保证**冲突操作次序不变**的情况下，可以通过**交换两个事务不冲突操作的次序**，得到另一个串行调度$Sc’$，则调度$Sc$为**冲突可串行化调度**
		- 冲突操作：冲突操作是**不同事务**对**同一数据**的**读-写**操作以及**写-写**操作。 表示为：
			- 事务$T_i$读$x$，$T_j$写$x $—— $R_i(x)$与$W_j(x)$
			- 事务$T_i$写$x$，$T_j$写$x $—— $W_i(x)$与$W_j(x)$

		- 操作次序交换的约束条件
			- 不同事务的冲突操作，以及同一个事务的两个操作不能交换

	- **一个冲突可串行化调度，一定是可串行化调度**


# 十、分布式数据库系统

## (一)分布式数据库的定义与特点

### 1、定义

- **分布式数据库**是由一组分布在计算机网络的不同 结点上的数据组成，每个结点具有独立处理的能 力（称为场地自治），可以执行局部应用，同时 每个结点也能通过网络通信支持全局应用。
	- 局部应用：只操作一个结点上 数据库的应用
	- 全局应用：操作两个或两个以上节点上数据库的应用
- 分布式数据库以“数据分布”为前提，强调场 地自治性（局部应用）以及自治场地之间的协 作性（全局应用），两者缺一不可：
	- **场地自治性**：每个场地有自己的数据库、一组终端、 运行局部DBMS，是独立的DBS，具有高度自治性。
	- **自治场地之间的协作性**：各结点组成整体。整体性的含义是，从用户角度看，分布式数据库系统逻辑 上如同一个集中式数据库一样，用户可以在任何场 地执行全局应用。

### 2、特点

- 1、数据独立性
	- 数据的逻辑独立性和物理独立性
	- 数据的**分布独立性（也称分布透明性）**：数据的逻辑分片、数据物理位置分布的细节、重复副本 （冗余数据）一致性问题、局部结点上的数据模型等与用户程序无关
- 2、集中与自治相结合的控制结构
	- 数据的共享有两个层次：
		- 一是**局部共享**，即在局部数据库中存储局部结点各用户的共享数据
		- 二是**全局共享**。即在分布式数据库系统的各个结点也存储供其 他结点的用户共享的数据，支持系统的全局应用
	- 分布式数据库系统常常采用集中和自治相结合的控制 结构
		- 各局部的DBMS可以独立的管理局部的数据库，具有**自治功能**
		- 系统又设有**集中控制结构**，协调各局部DBMS的工作，执行全局应用。

- 3、适当增加数据冗余
	- 在分布式数据库系统中适当的增加了冗余数据， **在不同的结点存储同一数据的多个副本**
		- **提高系统的可靠性、可用性**，当某一结点出现故障时， 系统可以对另一结点的相同副本进行操作，不会因为 一处故障而造成整个系统的瘫痪；
		- **高系统性能**，系统可以选择用户最近的数据副本来 进行操作，减少通信代价，改善整个系统的性能
	- 不利于更新，增加了系统维护代价
- 全局的一致性、可串行性和可恢复性
	- 分布式数据库系统除了各局部数据库应满足集 中式数据库的一致性、可串行性和可恢复性以 外，还应保证数据库的**全局一致性、并行操作的可串行性和系统的全局可恢复性**

## (二)分布式数据库系统的体系结构

### 1、分布式数据库系统的模式结构

- ![](https://s3.bmp.ovh/imgs/2022/12/13/c9593e4d0477311c.jpg)
- 全局外模式及全局外模式/全局概念模式映像（映像1）
	- 全局外模式是全局应用的用户视图，是全局概念模式 的子集；映像1定义全局外模式到全局概念模式的映像
- 全局概念模式
	- 定义分布式数据库中数据的整体逻辑结构，使得数据 如同没有分布一样
- 分片模式及全局概念模式/分片模式映象（映象2）
	- 每一个全局关系可以分为若干互不相交的部分，每一 部分称为一个片段。分片模式及映像2定义片段以及全局 关系到片段的映象。这种映象是一对多的
- 分布模式及分片模式/分布模式映象（映象3）
	- 定义片段的存放结点及片段到节点的映象。分布模式的映象类型确 定了分布式数据库是冗余的还是非冗余的。
- 分布模式/局部数据库概念模式映象（映象4）
	- 该映象把存储在局部场地的全局关系或全局关系的片段映象为各局 部概念模式

### 2、数据分片

- 分片的方式有多种

	- 水平分片，垂直分片—两种基本的分片方式
	- 混合分片，导出分片— 较复杂的分片方式

- 数据分片方式

	- **水平分片**：将关系依照一定条件按行分为不相交的若干子集，每 个子集称为一个水平片段
	- **垂直分片**：将关系按列分为若干属性子集，每个子集称为一个垂直片段。垂直分片的片段通过连接的方法恢复原关系。 因此垂直分片的诸片段通常都包含关系的码

	- **导出分片**：导出水平分片，分片的条件不是关系本身属性条件， 而是其它关系的属性条件。如SC（SNO，CNO，G） 按S关系中学生所在的系分片
	- **混合分片**：指按上述三种分片方式得到的片段，继续按另一种方 式分片

- 数据分片的约束

	- **完全性**：一个全局关系中的数据必须完全划分为若干片段，不 允许某些数据属于全局关系但不属于任何片段
	- **不相交性**：不允许一个全局关系的某些数据既属于该全局关系的 某一个片段，又属于另一个片段（垂直分片的码属性除外） 
	- **可重构性**：可以由片段重构全局关系
		- 垂直分片用连接操作重构，例$R$的码为$A$， $R1$，$R2$，$R3$为全局关系R的垂直分片，且都包含$A$，则 $R=R1\bowtie R2\bowtie R3$
		- 水平分片用并操作重构，例$SC_A,SC_B$为$SC$的两个水平分片， 则$SC=SC_A\cup SC_B$

### 3、分布透明性

- 分布透明性（分布独立性）包括：分片透明性，位置透明性，局部数据模型透明性
- **分片透明性**—用户或应用程序只对全局关系进行操作而不必考虑关系的分片。它是分布透明性的最高层次
- **位置透明性**—用户或应用程序不必了解片段的存储场地也不必关心各数据副本的一致性
- **局部数据模型透明性**—用户或应用程序不必了解局部场地上使用的是哪种数据模型。模型的转换以及查询语言 等的转换均由分布模式/局部概念模式（映象4）完成

### 4、分布式数据库管理系统DDBMS

- DDBMS的组成

	- LDBMS(局部场地上的数据库管理系统）：功能：建立和管理局部数据库，提供场地自治能力，执行局 部应用及全局查询的子查询。
	- GDBMS（全局数据库管理系统）：功能：提供分布透明性，协调全局事务的执行，协调各局部 DBMS以完成全局应用，并保证数据库的全局一致性，执行 并发控制，实现更新同步，提供全局恢复功能

	- GDD（全局数据字典）：
		- 存放全局概念模式、分片模式、分布模式的定义以及各模式 之间映象的定义
		- 存放有关用户存取权限的定义，以保证全局用户的合法权限和数据库的安全性
		- 存放数据完整性约束条件的定义
	- CM（通信管理）：在分布式数据库各场地之间传递消息和数据，完成通信功能

- DDBMS的分类
	- 按全局控制方式分类
		- 全局控制集中的DDBMS
			- 特点：GDBMS集中在某一结点上， GDD 只有一个，也放在该结点上
			- 优点： 控制简单，容易设计实现
			- 缺点： 易形成瓶颈，并且一旦该结点 出现故障，整个系统将瘫痪
		- 全局控制分散的DDBMS
			- 特点：GDBMS分散在每一个结点上。GDD 也在每个 结点上有一份。这类结构称为**完全分布的DDBMS**。
			- 优点：结点独立，自治性强，单个结点出现问题不会使系统瘫痪
			- 缺点：全局控制的协调机制和一致性维护都比较复杂
		- 全局控制部分分散的DDBMS：根据应用的需要将全局数据库管理器和全局数据字典 分散在某些结点上。介于上述两者之间的体系结构
	- 按局部DBMS的类型分类
		- 同构型DDBMS：每个结点的局部数据库具有相同的DBMS，即使硬件与操作系统不相同
		- 异构型DDBMS：各结点的局部数据库具有不同的DBMS

## (三)分布式数据库系统的主要技术

### 1、分布式查询处理和优化

- 分布式查询类型

	在分布式数据库系统中，查询可分为三类：局部查询，远程查询，全局查询

	- 局部查询和远程查询只涉及单个结点的数据（本地的或远程的），可以采用集中式数据库的处理技术
	- 全局查询涉及到多个结点的数据，十分复杂

### 2、分布式查询处理过程

- **查询分解**：把全局查询分解为若干子查询，每个子查询只涉及某一个结点的 数据,可由局部DBMS处理。必须选择查询开销最省的那些结点 （物理片段）
- **选择操作执行的次序**：主要是确定涉及不同结点上关系的连接和并操作的次序
- **选择执行操作的方法**：包括选择存取路径、选择某种操作的算法以及连接的执行方法

### 3、6种可能的查询策略

- 1、把关系P从B站传送到A站，在A站进行查询

- 2、把关系S，SP从A站传送到B站，在B站进行查询

- 3、在A站连接S与SP，选出城市为北京的元组 （有105个），然后对其中每个元组的P#， 询问B站，看其是否为红色

- 4、在B站选出红色零件（有10个），然后对 每个元组询问A站，看北京的供应商是否供应此零件

- 5、在A站选出北京的供应商的装运单（105 个），传送到B站，在B站完成查询。

- 6、在B站选出红色零件（10个），把结果传 送到A站，在A站完成查询。

- ```
	S(S#,CITY) 10e4个元组
	P(P#,COLOR) 10e5个元组
	P(S#,P#) 10e6个元组
	红色零件数=10；
	北京供应商的装运单数=10e5
	```



### 4、连接查询的优化

- 半连接：使用半连接来缩减关系（或片段）进而节省传输开销

- 半连接定义：<img src="https://s3.bmp.ovh/imgs/2022/12/13/029dbbe3a7469ed3.jpg" style="zoom:25%;" />

- 根据半连接定义，有：<img src="https://s3.bmp.ovh/imgs/2022/12/13/dc7114acd25cf525.jpg" style="zoom:25%;" />



### 5、分布事务处理

- 分布事务的原子性与可串行性
	- 在分布式数据库系统中，一个全局事务被划分为在许多结点上的子事务
	- 分布事务的原子性是：组成该事务的所有子事务要么一致地全部提交，要么一致地全部回滚
	- 在多用户系统中，还必须保证分布式事务的可串行性
- 分布事务管理主要包括：事务的恢复和并发控制

#### (1)分布事务的恢复

- 每个场地都有一个**局部事务管理器**，负责管理局部子事务的执行。同时，**各局部事务管理器之间必须相互协调，保证分布事务的原子性**：各子事务要么都提交，要么都回滚

- 对局部事务管理器进行协调，保证分布事 务原子性最常用的技术—— 两段提交协议 ( 2- Phase-Commitment Protocol)

- 两段提交协议

	两段提交协议把一个分布事务的所有局部 事务管理分为两类：协调者（一个），参与者

	- 协调者：负责作出该事务是提交还是撤消的最后决定
	- 参与者：负责管理相应子事务的执行以及在各 自局部数据库上执行写操作

- 两段提交协议内容

	- 第一阶段：协调者征求意见作决定
		- 协调者向所有参与者发出“准备提交”信息，并记入日志； 参与者准备提交就回答“就绪”，否则回答“撤消”，并记 入日志
		- 如果在规定时间内，协调者收到所有参与者的“就绪”信息， 则作出“提交”决定，否则将作出“撤消”决定
	- 第二阶段：参与者执行决定
		- 协调者将有关决定写入日志，然后把这个决定发送给所有的 参与者
		- 所有参与者收到命令后，首先在日志中记入“收到提交/撤消 决定”的信息，并向协调者发送应答消息，最后执行相应决 定
		- 协调者收到所有参与者的应答消息后，一个事务的执行到此 结束。有关日志信息可以脱机保存

- 采用两段提交协议后，当系统发生故障时，各场地利用 各自有关的日志进行事务恢复

#### (2)并发控制

- 分布式数据库系统中的并发控制也可以采 用封锁技术，但并发控制更加复杂
	- 分布式数据库系统支持多副本
	- 由于事务的分布执行，封锁的方法会引起全局死锁
- 分布式数据库系统并发控制进一步的策略
	- 处理多副本封锁的几种可行方法
		- 对写操作，要申请所有副本的X锁；对读操作，只 要申请某个副本的S锁
		- 无论是写操作还是读操作都要对大多数副本申请X 锁或S锁
		- 规定某个场地上的副本为主副本，所有的读、写操 作均申请对主副本的封锁
	- 解决全局死锁（两个以上场地上发生死锁）
		- 死锁检测及解除方式
		- 死锁预防，如对事务按某一标准进行排序，只允许事务按这一次序单向等待
